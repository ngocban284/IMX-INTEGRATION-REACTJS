{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplySemigroup = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.duplicate = exports.extend = exports.throwError = exports.zero = exports.alt = exports.altW = exports.flatten = exports.chainFirst = exports.chain = exports.of = exports.apSecond = exports.apFirst = exports.ap = exports.map = exports.chainNullableK = exports.mapNullable = exports.fromNullableK = exports.getOrElse = exports.getOrElseW = exports.toUndefined = exports.toNullable = exports.fold = exports.fromEither = exports.getRight = exports.getLeft = exports.tryCatch = exports.fromPredicate = exports.fromNullable = exports.some = exports.none = exports.isNone = exports.isSome = void 0;\nexports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.getRefinement = exports.exists = exports.elem = exports.option = exports.MonadThrow = exports.Witherable = exports.Traversable = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.Alt = exports.Foldable = exports.Monad = exports.Applicative = exports.Functor = exports.getMonoid = exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = void 0;\n\nvar function_1 = require(\"./function\"); // -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\n\n\nvar isSome = function (fa) {\n  return fa._tag === 'Some';\n};\n\nexports.isSome = isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\n\nvar isNone = function (fa) {\n  return fa._tag === 'None';\n};\n\nexports.isNone = isNone; // -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexports.none = {\n  _tag: 'None'\n};\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nvar some = function (a) {\n  return {\n    _tag: 'Some',\n    value: a\n  };\n};\n\nexports.some = some;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nfunction fromNullable(a) {\n  return a == null ? exports.none : exports.some(a);\n}\n\nexports.fromNullable = fromNullable;\n\nfunction fromPredicate(predicate) {\n  return function (a) {\n    return predicate(a) ? exports.some(a) : exports.none;\n  };\n}\n\nexports.fromPredicate = fromPredicate;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nfunction tryCatch(f) {\n  try {\n    return exports.some(f());\n  } catch (e) {\n    return exports.none;\n  }\n}\n\nexports.tryCatch = tryCatch;\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nfunction getLeft(ma) {\n  return ma._tag === 'Right' ? exports.none : exports.some(ma.left);\n}\n\nexports.getLeft = getLeft;\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\n\nfunction getRight(ma) {\n  return ma._tag === 'Left' ? exports.none : exports.some(ma.right);\n}\n\nexports.getRight = getRight;\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexports.fromEither = getRight; // -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nfunction fold(onNone, onSome) {\n  return function (ma) {\n    return exports.isNone(ma) ? onNone() : onSome(ma.value);\n  };\n}\n\nexports.fold = fold;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nfunction toNullable(ma) {\n  return exports.isNone(ma) ? null : ma.value;\n}\n\nexports.toNullable = toNullable;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nfunction toUndefined(ma) {\n  return exports.isNone(ma) ? undefined : ma.value;\n}\n\nexports.toUndefined = toUndefined;\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\n\nvar getOrElseW = function (onNone) {\n  return function (ma) {\n    return exports.isNone(ma) ? onNone() : ma.value;\n  };\n};\n\nexports.getOrElseW = getOrElseW;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nexports.getOrElse = exports.getOrElseW; // -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\n\nfunction fromNullableK(f) {\n  return function () {\n    var a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      a[_i] = arguments[_i];\n    }\n\n    return fromNullable(f.apply(void 0, a));\n  };\n}\n\nexports.fromNullableK = fromNullableK;\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\n\nexports.mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\n\nfunction chainNullableK(f) {\n  return function (ma) {\n    return exports.isNone(ma) ? exports.none : fromNullable(f(ma.value));\n  };\n}\n\nexports.chainNullableK = chainNullableK; // -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nvar map_ = function (fa, f) {\n  return function_1.pipe(fa, exports.map(f));\n};\n\nvar ap_ = function (fab, fa) {\n  return function_1.pipe(fab, exports.ap(fa));\n};\n\nvar chain_ = function (ma, f) {\n  return function_1.pipe(ma, exports.chain(f));\n};\n\nvar reduce_ = function (fa, b, f) {\n  return function_1.pipe(fa, exports.reduce(b, f));\n};\n\nvar foldMap_ = function (M) {\n  var foldMapM = exports.foldMap(M);\n  return function (fa, f) {\n    return function_1.pipe(fa, foldMapM(f));\n  };\n};\n\nvar reduceRight_ = function (fa, b, f) {\n  return function_1.pipe(fa, exports.reduceRight(b, f));\n};\n\nvar traverse_ = function (F) {\n  var traverseF = exports.traverse(F);\n  return function (ta, f) {\n    return function_1.pipe(ta, traverseF(f));\n  };\n};\n/* istanbul ignore next */\n\n\nvar alt_ = function (fa, that) {\n  return function_1.pipe(fa, exports.alt(that));\n};\n\nvar filter_ = function (fa, predicate) {\n  return function_1.pipe(fa, exports.filter(predicate));\n};\n/* istanbul ignore next */\n\n\nvar filterMap_ = function (fa, f) {\n  return function_1.pipe(fa, exports.filterMap(f));\n};\n/* istanbul ignore next */\n\n\nvar extend_ = function (wa, f) {\n  return function_1.pipe(wa, exports.extend(f));\n};\n/* istanbul ignore next */\n\n\nvar partition_ = function (fa, predicate) {\n  return function_1.pipe(fa, exports.partition(predicate));\n};\n/* istanbul ignore next */\n\n\nvar partitionMap_ = function (fa, f) {\n  return function_1.pipe(fa, exports.partitionMap(f));\n};\n/* istanbul ignore next */\n\n\nvar wither_ = function (F) {\n  var witherF = exports.wither(F);\n  return function (fa, f) {\n    return function_1.pipe(fa, witherF(f));\n  };\n};\n/* istanbul ignore next */\n\n\nvar wilt_ = function (F) {\n  var wiltF = exports.wilt(F);\n  return function (fa, f) {\n    return function_1.pipe(fa, wiltF(f));\n  };\n}; // -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\n\n\nvar map = function (f) {\n  return function (fa) {\n    return exports.isNone(fa) ? exports.none : exports.some(f(fa.value));\n  };\n};\n\nexports.map = map;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\n\nvar ap = function (fa) {\n  return function (fab) {\n    return exports.isNone(fab) ? exports.none : exports.isNone(fa) ? exports.none : exports.some(fab.value(fa.value));\n  };\n};\n\nexports.ap = ap;\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nvar apFirst = function (fb) {\n  return function_1.flow(exports.map(function (a) {\n    return function () {\n      return a;\n    };\n  }), exports.ap(fb));\n};\n\nexports.apFirst = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nvar apSecond = function (fb) {\n  return function_1.flow(exports.map(function () {\n    return function (b) {\n      return b;\n    };\n  }), exports.ap(fb));\n};\n\nexports.apSecond = apSecond;\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\n\nexports.of = exports.some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\n\nvar chain = function (f) {\n  return function (ma) {\n    return exports.isNone(ma) ? exports.none : f(ma.value);\n  };\n};\n\nexports.chain = chain;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nvar chainFirst = function (f) {\n  return exports.chain(function (a) {\n    return function_1.pipe(f(a), exports.map(function () {\n      return a;\n    }));\n  });\n};\n\nexports.chainFirst = chainFirst;\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexports.flatten = /*#__PURE__*/exports.chain(function_1.identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\n\nvar altW = function (that) {\n  return function (fa) {\n    return exports.isNone(fa) ? that() : fa;\n  };\n};\n\nexports.altW = altW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\n\nexports.alt = exports.altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\n\nvar zero = function () {\n  return exports.none;\n};\n\nexports.zero = zero;\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\n\nvar throwError = function () {\n  return exports.none;\n};\n\nexports.throwError = throwError;\n/**\n * @category Extend\n * @since 2.0.0\n */\n\nvar extend = function (f) {\n  return function (wa) {\n    return exports.isNone(wa) ? exports.none : exports.some(f(wa));\n  };\n};\n\nexports.extend = extend;\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexports.duplicate = /*#__PURE__*/exports.extend(function_1.identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nvar reduce = function (b, f) {\n  return function (fa) {\n    return exports.isNone(fa) ? b : f(b, fa.value);\n  };\n};\n\nexports.reduce = reduce;\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nvar foldMap = function (M) {\n  return function (f) {\n    return function (fa) {\n      return exports.isNone(fa) ? M.empty : f(fa.value);\n    };\n  };\n};\n\nexports.foldMap = foldMap;\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nvar reduceRight = function (b, f) {\n  return function (fa) {\n    return exports.isNone(fa) ? b : f(fa.value, b);\n  };\n};\n\nexports.reduceRight = reduceRight;\n/**\n * @category Compactable\n * @since 2.0.0\n */\n\nexports.compact = exports.flatten;\nvar defaultSeparate = {\n  left: exports.none,\n  right: exports.none\n};\n/**\n * @category Compactable\n * @since 2.0.0\n */\n\nvar separate = function (ma) {\n  var o = function_1.pipe(ma, exports.map(function (e) {\n    return {\n      left: getLeft(e),\n      right: getRight(e)\n    };\n  }));\n  return exports.isNone(o) ? defaultSeparate : o.value;\n};\n\nexports.separate = separate;\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nvar filter = function (predicate) {\n  return function (fa) {\n    return exports.isNone(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;\n  };\n};\n\nexports.filter = filter;\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nvar filterMap = function (f) {\n  return function (fa) {\n    return exports.isNone(fa) ? exports.none : f(fa.value);\n  };\n};\n\nexports.filterMap = filterMap;\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nvar partition = function (predicate) {\n  return function (fa) {\n    return {\n      left: filter_(fa, function (a) {\n        return !predicate(a);\n      }),\n      right: filter_(fa, predicate)\n    };\n  };\n};\n\nexports.partition = partition;\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nvar partitionMap = function (f) {\n  return function_1.flow(exports.map(f), exports.separate);\n};\n\nexports.partitionMap = partitionMap;\n/**\n * @category Traversable\n * @since 2.6.3\n */\n\nvar traverse = function (F) {\n  return function (f) {\n    return function (ta) {\n      return exports.isNone(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);\n    };\n  };\n};\n\nexports.traverse = traverse;\n/**\n * @category Traversable\n * @since 2.6.3\n */\n\nvar sequence = function (F) {\n  return function (ta) {\n    return exports.isNone(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);\n  };\n};\n\nexports.sequence = sequence;\n/**\n * @category Witherable\n * @since 2.6.5\n */\n\nvar wither = function (F) {\n  return function (f) {\n    return function (fa) {\n      return exports.isNone(fa) ? F.of(exports.none) : f(fa.value);\n    };\n  };\n};\n\nexports.wither = wither;\n/**\n * @category Witherable\n * @since 2.6.5\n */\n\nvar wilt = function (F) {\n  return function (f) {\n    return function (fa) {\n      return exports.isNone(fa) ? F.of({\n        left: exports.none,\n        right: exports.none\n      }) : F.map(f(fa.value), function (e) {\n        return {\n          left: getLeft(e),\n          right: getRight(e)\n        };\n      });\n    };\n  };\n};\n\nexports.wilt = wilt; // -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexports.URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\n\nfunction getShow(S) {\n  return {\n    show: function (ma) {\n      return exports.isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\";\n    }\n  };\n}\n\nexports.getShow = getShow;\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getEq(E) {\n  return {\n    equals: function (x, y) {\n      return x === y || (exports.isNone(x) ? exports.isNone(y) : exports.isNone(y) ? false : E.equals(x.value, y.value));\n    }\n  };\n}\n\nexports.getEq = getEq;\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getOrd(O) {\n  return {\n    equals: getEq(O).equals,\n    compare: function (x, y) {\n      return x === y ? 0 : exports.isSome(x) ? exports.isSome(y) ? O.compare(x.value, y.value) : 1 : -1;\n    }\n  };\n}\n\nexports.getOrd = getOrd;\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getApplySemigroup(S) {\n  return {\n    concat: function (x, y) {\n      return exports.isSome(x) && exports.isSome(y) ? exports.some(S.concat(x.value, y.value)) : exports.none;\n    }\n  };\n}\n\nexports.getApplySemigroup = getApplySemigroup;\n/**\n * @category instances\n * @since 2.0.0\n */\n\nfunction getApplyMonoid(M) {\n  return {\n    concat: getApplySemigroup(M).concat,\n    empty: exports.some(M.empty)\n  };\n}\n\nexports.getApplyMonoid = getApplyMonoid;\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getFirstMonoid() {\n  return {\n    concat: function (x, y) {\n      return exports.isNone(x) ? y : x;\n    },\n    empty: exports.none\n  };\n}\n\nexports.getFirstMonoid = getFirstMonoid;\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getLastMonoid() {\n  return {\n    concat: function (x, y) {\n      return exports.isNone(y) ? x : y;\n    },\n    empty: exports.none\n  };\n}\n\nexports.getLastMonoid = getLastMonoid;\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\n\nfunction getMonoid(S) {\n  return {\n    concat: function (x, y) {\n      return exports.isNone(x) ? y : exports.isNone(y) ? x : exports.some(S.concat(x.value, y.value));\n    },\n    empty: exports.none\n  };\n}\n\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Functor = {\n  URI: exports.URI,\n  map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Applicative = {\n  URI: exports.URI,\n  map: map_,\n  ap: ap_,\n  of: exports.of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Monad = {\n  URI: exports.URI,\n  map: map_,\n  ap: ap_,\n  of: exports.of,\n  chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Foldable = {\n  URI: exports.URI,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Alt = {\n  URI: exports.URI,\n  map: map_,\n  alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Alternative = {\n  URI: exports.URI,\n  map: map_,\n  ap: ap_,\n  of: exports.of,\n  alt: alt_,\n  zero: exports.zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Extend = {\n  URI: exports.URI,\n  map: map_,\n  extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Compactable = {\n  URI: exports.URI,\n  compact: exports.compact,\n  separate: exports.separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Filterable = {\n  URI: exports.URI,\n  map: map_,\n  compact: exports.compact,\n  separate: exports.separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Traversable = {\n  URI: exports.URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: exports.sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.Witherable = {\n  URI: exports.URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: exports.sequence,\n  compact: exports.compact,\n  separate: exports.separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexports.MonadThrow = {\n  URI: exports.URI,\n  map: map_,\n  ap: ap_,\n  of: exports.of,\n  chain: chain_,\n  throwError: exports.throwError\n}; // TODO: remove in v3\n\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexports.option = {\n  URI: exports.URI,\n  map: map_,\n  of: exports.of,\n  ap: ap_,\n  chain: chain_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: exports.sequence,\n  zero: exports.zero,\n  alt: alt_,\n  extend: extend_,\n  compact: exports.compact,\n  separate: exports.separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_,\n  throwError: exports.throwError\n}; // -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\n\nfunction elem(E) {\n  return function (a, ma) {\n    return exports.isNone(ma) ? false : E.equals(a, ma.value);\n  };\n}\n\nexports.elem = elem;\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\n\nfunction exists(predicate) {\n  return function (ma) {\n    return exports.isNone(ma) ? false : predicate(ma.value);\n  };\n}\n\nexports.exists = exists;\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\n\nfunction getRefinement(getOption) {\n  return function (a) {\n    return exports.isSome(getOption(a));\n  };\n}\n\nexports.getRefinement = getRefinement; // -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.9.0\n */\n\nexports.Do = /*#__PURE__*/exports.of({});\n/**\n * @since 2.8.0\n */\n\nvar bindTo = function (name) {\n  return exports.map(function_1.bindTo_(name));\n};\n\nexports.bindTo = bindTo;\n/**\n * @since 2.8.0\n */\n\nvar bind = function (name, f) {\n  return exports.chain(function (a) {\n    return function_1.pipe(f(a), exports.map(function (b) {\n      return function_1.bind_(a, name, b);\n    }));\n  });\n};\n\nexports.bind = bind; // -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.8.0\n */\n\nvar apS = function (name, fb) {\n  return function_1.flow(exports.map(function (a) {\n    return function (b) {\n      return function_1.bind_(a, name, b);\n    };\n  }), exports.ap(fb));\n};\n\nexports.apS = apS; // -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n\n/**\n *\n * @since 2.9.0\n */\n\nvar traverseArrayWithIndex = function (f) {\n  return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n\n    for (var i = 0; i < arr.length; i++) {\n      var b = f(i, arr[i]);\n\n      if (exports.isNone(b)) {\n        return exports.none;\n      }\n\n      result.push(b.value);\n    }\n\n    return exports.some(result);\n  };\n};\n\nexports.traverseArrayWithIndex = traverseArrayWithIndex;\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\n\nvar traverseArray = function (f) {\n  return exports.traverseArrayWithIndex(function (_, a) {\n    return f(a);\n  });\n};\n\nexports.traverseArray = traverseArray;\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\n\nexports.sequenceArray = /*#__PURE__*/exports.traverseArray(function_1.identity);","map":{"version":3,"names":["Object","defineProperty","exports","value","getApplySemigroup","getOrd","getEq","getShow","URI","wilt","wither","sequence","traverse","partitionMap","partition","filterMap","filter","separate","compact","reduceRight","foldMap","reduce","duplicate","extend","throwError","zero","alt","altW","flatten","chainFirst","chain","of","apSecond","apFirst","ap","map","chainNullableK","mapNullable","fromNullableK","getOrElse","getOrElseW","toUndefined","toNullable","fold","fromEither","getRight","getLeft","tryCatch","fromPredicate","fromNullable","some","none","isNone","isSome","sequenceArray","traverseArray","traverseArrayWithIndex","apS","bind","bindTo","Do","getRefinement","exists","elem","option","MonadThrow","Witherable","Traversable","Filterable","Compactable","Extend","Alternative","Alt","Foldable","Monad","Applicative","Functor","getMonoid","getLastMonoid","getFirstMonoid","getApplyMonoid","function_1","require","fa","_tag","a","predicate","f","e","ma","left","right","onNone","onSome","undefined","_i","arguments","length","apply","map_","pipe","ap_","fab","chain_","reduce_","b","foldMap_","M","foldMapM","reduceRight_","traverse_","F","traverseF","ta","alt_","that","filter_","filterMap_","extend_","wa","partition_","partitionMap_","wither_","witherF","wilt_","wiltF","fb","flow","identity","empty","defaultSeparate","o","S","show","E","equals","x","y","O","compare","concat","getOption","name","bindTo_","bind_","arr","result","i","push","_"],"sources":["/Users/ngocban/Desktop/imx-integration-reactjs/node_modules/fp-ts/lib/Option.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApplySemigroup = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.duplicate = exports.extend = exports.throwError = exports.zero = exports.alt = exports.altW = exports.flatten = exports.chainFirst = exports.chain = exports.of = exports.apSecond = exports.apFirst = exports.ap = exports.map = exports.chainNullableK = exports.mapNullable = exports.fromNullableK = exports.getOrElse = exports.getOrElseW = exports.toUndefined = exports.toNullable = exports.fold = exports.fromEither = exports.getRight = exports.getLeft = exports.tryCatch = exports.fromPredicate = exports.fromNullable = exports.some = exports.none = exports.isNone = exports.isSome = void 0;\nexports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.getRefinement = exports.exists = exports.elem = exports.option = exports.MonadThrow = exports.Witherable = exports.Traversable = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.Alt = exports.Foldable = exports.Monad = exports.Applicative = exports.Functor = exports.getMonoid = exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = void 0;\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nvar isSome = function (fa) { return fa._tag === 'Some'; };\nexports.isSome = isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.none = { _tag: 'None' };\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nvar some = function (a) { return ({ _tag: 'Some', value: a }); };\nexports.some = some;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction fromNullable(a) {\n    return a == null ? exports.none : exports.some(a);\n}\nexports.fromNullable = fromNullable;\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? exports.some(a) : exports.none); };\n}\nexports.fromPredicate = fromPredicate;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction tryCatch(f) {\n    try {\n        return exports.some(f());\n    }\n    catch (e) {\n        return exports.none;\n    }\n}\nexports.tryCatch = tryCatch;\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction getLeft(ma) {\n    return ma._tag === 'Right' ? exports.none : exports.some(ma.left);\n}\nexports.getLeft = getLeft;\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction getRight(ma) {\n    return ma._tag === 'Left' ? exports.none : exports.some(ma.right);\n}\nexports.getRight = getRight;\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.fromEither = getRight;\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nfunction fold(onNone, onSome) {\n    return function (ma) { return (exports.isNone(ma) ? onNone() : onSome(ma.value)); };\n}\nexports.fold = fold;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nfunction toNullable(ma) {\n    return exports.isNone(ma) ? null : ma.value;\n}\nexports.toNullable = toNullable;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nfunction toUndefined(ma) {\n    return exports.isNone(ma) ? undefined : ma.value;\n}\nexports.toUndefined = toUndefined;\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nvar getOrElseW = function (onNone) { return function (ma) { return (exports.isNone(ma) ? onNone() : ma.value); }; };\nexports.getOrElseW = getOrElseW;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexports.getOrElse = exports.getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\nfunction fromNullableK(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromNullable(f.apply(void 0, a));\n    };\n}\nexports.fromNullableK = fromNullableK;\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexports.mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\nfunction chainNullableK(f) {\n    return function (ma) { return (exports.isNone(ma) ? exports.none : fromNullable(f(ma.value))); };\n}\nexports.chainNullableK = chainNullableK;\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (fa, f) { return function_1.pipe(fa, exports.map(f)); };\nvar ap_ = function (fab, fa) { return function_1.pipe(fab, exports.ap(fa)); };\nvar chain_ = function (ma, f) { return function_1.pipe(ma, exports.chain(f)); };\nvar reduce_ = function (fa, b, f) { return function_1.pipe(fa, exports.reduce(b, f)); };\nvar foldMap_ = function (M) {\n    var foldMapM = exports.foldMap(M);\n    return function (fa, f) { return function_1.pipe(fa, foldMapM(f)); };\n};\nvar reduceRight_ = function (fa, b, f) { return function_1.pipe(fa, exports.reduceRight(b, f)); };\nvar traverse_ = function (F) {\n    var traverseF = exports.traverse(F);\n    return function (ta, f) { return function_1.pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar alt_ = function (fa, that) { return function_1.pipe(fa, exports.alt(that)); };\nvar filter_ = function (fa, predicate) {\n    return function_1.pipe(fa, exports.filter(predicate));\n};\n/* istanbul ignore next */\nvar filterMap_ = function (fa, f) { return function_1.pipe(fa, exports.filterMap(f)); };\n/* istanbul ignore next */\nvar extend_ = function (wa, f) { return function_1.pipe(wa, exports.extend(f)); };\n/* istanbul ignore next */\nvar partition_ = function (fa, predicate) { return function_1.pipe(fa, exports.partition(predicate)); };\n/* istanbul ignore next */\nvar partitionMap_ = function (fa, f) { return function_1.pipe(fa, exports.partitionMap(f)); };\n/* istanbul ignore next */\nvar wither_ = function (F) {\n    var witherF = exports.wither(F);\n    return function (fa, f) { return function_1.pipe(fa, witherF(f)); };\n};\n/* istanbul ignore next */\nvar wilt_ = function (F) {\n    var wiltF = exports.wilt(F);\n    return function (fa, f) { return function_1.pipe(fa, wiltF(f)); };\n};\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nvar map = function (f) { return function (fa) {\n    return exports.isNone(fa) ? exports.none : exports.some(f(fa.value));\n}; };\nexports.map = map;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nvar ap = function (fa) { return function (fab) {\n    return exports.isNone(fab) ? exports.none : exports.isNone(fa) ? exports.none : exports.some(fab.value(fa.value));\n}; };\nexports.ap = ap;\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nvar apFirst = function (fb) {\n    return function_1.flow(exports.map(function (a) { return function () { return a; }; }), exports.ap(fb));\n};\nexports.apFirst = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nvar apSecond = function (fb) {\n    return function_1.flow(exports.map(function () { return function (b) { return b; }; }), exports.ap(fb));\n};\nexports.apSecond = apSecond;\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\nexports.of = exports.some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nvar chain = function (f) { return function (ma) {\n    return exports.isNone(ma) ? exports.none : f(ma.value);\n}; };\nexports.chain = chain;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nvar chainFirst = function (f) {\n    return exports.chain(function (a) {\n        return function_1.pipe(f(a), exports.map(function () { return a; }));\n    });\n};\nexports.chainFirst = chainFirst;\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexports.flatten = \n/*#__PURE__*/\nexports.chain(function_1.identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nvar altW = function (that) { return function (fa) {\n    return exports.isNone(fa) ? that() : fa;\n}; };\nexports.altW = altW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\nexports.alt = exports.altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\nvar zero = function () { return exports.none; };\nexports.zero = zero;\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\nvar throwError = function () { return exports.none; };\nexports.throwError = throwError;\n/**\n * @category Extend\n * @since 2.0.0\n */\nvar extend = function (f) { return function (wa) {\n    return exports.isNone(wa) ? exports.none : exports.some(f(wa));\n}; };\nexports.extend = extend;\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexports.duplicate = \n/*#__PURE__*/\nexports.extend(function_1.identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\nvar reduce = function (b, f) { return function (fa) {\n    return exports.isNone(fa) ? b : f(b, fa.value);\n}; };\nexports.reduce = reduce;\n/**\n * @category Foldable\n * @since 2.0.0\n */\nvar foldMap = function (M) { return function (f) { return function (fa) {\n    return exports.isNone(fa) ? M.empty : f(fa.value);\n}; }; };\nexports.foldMap = foldMap;\n/**\n * @category Foldable\n * @since 2.0.0\n */\nvar reduceRight = function (b, f) { return function (fa) {\n    return exports.isNone(fa) ? b : f(fa.value, b);\n}; };\nexports.reduceRight = reduceRight;\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexports.compact = exports.flatten;\nvar defaultSeparate = { left: exports.none, right: exports.none };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nvar separate = function (ma) {\n    var o = function_1.pipe(ma, exports.map(function (e) { return ({\n        left: getLeft(e),\n        right: getRight(e)\n    }); }));\n    return exports.isNone(o) ? defaultSeparate : o.value;\n};\nexports.separate = separate;\n/**\n * @category Filterable\n * @since 2.0.0\n */\nvar filter = function (predicate) { return function (fa) { return (exports.isNone(fa) ? exports.none : predicate(fa.value) ? fa : exports.none); }; };\nexports.filter = filter;\n/**\n * @category Filterable\n * @since 2.0.0\n */\nvar filterMap = function (f) { return function (fa) {\n    return exports.isNone(fa) ? exports.none : f(fa.value);\n}; };\nexports.filterMap = filterMap;\n/**\n * @category Filterable\n * @since 2.0.0\n */\nvar partition = function (predicate) { return function (fa) {\n    return {\n        left: filter_(fa, function (a) { return !predicate(a); }),\n        right: filter_(fa, predicate)\n    };\n}; };\nexports.partition = partition;\n/**\n * @category Filterable\n * @since 2.0.0\n */\nvar partitionMap = function (f) { return function_1.flow(exports.map(f), exports.separate); };\nexports.partitionMap = partitionMap;\n/**\n * @category Traversable\n * @since 2.6.3\n */\nvar traverse = function (F) { return function (f) { return function (ta) { return (exports.isNone(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some)); }; }; };\nexports.traverse = traverse;\n/**\n * @category Traversable\n * @since 2.6.3\n */\nvar sequence = function (F) { return function (ta) { return (exports.isNone(ta) ? F.of(exports.none) : F.map(ta.value, exports.some)); }; };\nexports.sequence = sequence;\n/**\n * @category Witherable\n * @since 2.6.5\n */\nvar wither = function (F) { return function (f) { return function (fa) { return (exports.isNone(fa) ? F.of(exports.none) : f(fa.value)); }; }; };\nexports.wither = wither;\n/**\n * @category Witherable\n * @since 2.6.5\n */\nvar wilt = function (F) { return function (f) { return function (fa) {\n    return exports.isNone(fa)\n        ? F.of({\n            left: exports.none,\n            right: exports.none\n        })\n        : F.map(f(fa.value), function (e) { return ({\n            left: getLeft(e),\n            right: getRight(e)\n        }); });\n}; }; };\nexports.wilt = wilt;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexports.URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getShow(S) {\n    return {\n        show: function (ma) { return (exports.isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\"); }\n    };\n}\nexports.getShow = getShow;\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getEq(E) {\n    return {\n        equals: function (x, y) { return x === y || (exports.isNone(x) ? exports.isNone(y) : exports.isNone(y) ? false : E.equals(x.value, y.value)); }\n    };\n}\nexports.getEq = getEq;\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getOrd(O) {\n    return {\n        equals: getEq(O).equals,\n        compare: function (x, y) { return (x === y ? 0 : exports.isSome(x) ? (exports.isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n    };\n}\nexports.getOrd = getOrd;\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (exports.isSome(x) && exports.isSome(y) ? exports.some(S.concat(x.value, y.value)) : exports.none); }\n    };\n}\nexports.getApplySemigroup = getApplySemigroup;\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getApplyMonoid(M) {\n    return {\n        concat: getApplySemigroup(M).concat,\n        empty: exports.some(M.empty)\n    };\n}\nexports.getApplyMonoid = getApplyMonoid;\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getFirstMonoid() {\n    return {\n        concat: function (x, y) { return (exports.isNone(x) ? y : x); },\n        empty: exports.none\n    };\n}\nexports.getFirstMonoid = getFirstMonoid;\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getLastMonoid() {\n    return {\n        concat: function (x, y) { return (exports.isNone(y) ? x : y); },\n        empty: exports.none\n    };\n}\nexports.getLastMonoid = getLastMonoid;\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nfunction getMonoid(S) {\n    return {\n        concat: function (x, y) { return (exports.isNone(x) ? y : exports.isNone(y) ? x : exports.some(S.concat(x.value, y.value))); },\n        empty: exports.none\n    };\n}\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: map_,\n    ap: ap_,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: map_,\n    ap: ap_,\n    of: exports.of,\n    chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: map_,\n    alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alternative = {\n    URI: exports.URI,\n    map: map_,\n    ap: ap_,\n    of: exports.of,\n    alt: alt_,\n    zero: exports.zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Extend = {\n    URI: exports.URI,\n    map: map_,\n    extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Compactable = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Filterable = {\n    URI: exports.URI,\n    map: map_,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: exports.sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Witherable = {\n    URI: exports.URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: exports.sequence,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.MonadThrow = {\n    URI: exports.URI,\n    map: map_,\n    ap: ap_,\n    of: exports.of,\n    chain: chain_,\n    throwError: exports.throwError\n};\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexports.option = {\n    URI: exports.URI,\n    map: map_,\n    of: exports.of,\n    ap: ap_,\n    chain: chain_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: exports.sequence,\n    zero: exports.zero,\n    alt: alt_,\n    extend: extend_,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_,\n    throwError: exports.throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nfunction elem(E) {\n    return function (a, ma) { return (exports.isNone(ma) ? false : E.equals(a, ma.value)); };\n}\nexports.elem = elem;\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nfunction exists(predicate) {\n    return function (ma) { return (exports.isNone(ma) ? false : predicate(ma.value)); };\n}\nexports.exists = exists;\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nfunction getRefinement(getOption) {\n    return function (a) { return exports.isSome(getOption(a)); };\n}\nexports.getRefinement = getRefinement;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexports.Do = \n/*#__PURE__*/\nexports.of({});\n/**\n * @since 2.8.0\n */\nvar bindTo = function (name) { return exports.map(function_1.bindTo_(name)); };\nexports.bindTo = bindTo;\n/**\n * @since 2.8.0\n */\nvar bind = function (name, f) {\n    return exports.chain(function (a) {\n        return function_1.pipe(f(a), exports.map(function (b) { return function_1.bind_(a, name, b); }));\n    });\n};\nexports.bind = bind;\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nvar apS = function (name, fb) {\n    return function_1.flow(exports.map(function (a) { return function (b) { return function_1.bind_(a, name, b); }; }), exports.ap(fb));\n};\nexports.apS = apS;\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n *\n * @since 2.9.0\n */\nvar traverseArrayWithIndex = function (f) { return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = f(i, arr[i]);\n        if (exports.isNone(b)) {\n            return exports.none;\n        }\n        result.push(b.value);\n    }\n    return exports.some(result);\n}; };\nexports.traverseArrayWithIndex = traverseArrayWithIndex;\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\nvar traverseArray = function (f) { return exports.traverseArrayWithIndex(function (_, a) { return f(a); }); };\nexports.traverseArray = traverseArray;\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\nexports.sequenceArray = \n/*#__PURE__*/\nexports.traverseArray(function_1.identity);\n"],"mappings":"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AAE,CAACL,IAAH,KAAY,OAAZ,GAAsBlF,OAAO,CAACiD,IAA9B,GAAqCjD,OAAO,CAACgD,IAAR,CAAauC,EAAE,CAACC,IAAhB,CAA5C;AACH;;AACDxF,OAAO,CAAC4C,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,QAAT,CAAkB4C,EAAlB,EAAsB;EAClB,OAAOA,EAAE,CAACL,IAAH,KAAY,MAAZ,GAAqBlF,OAAO,CAACiD,IAA7B,GAAoCjD,OAAO,CAACgD,IAAR,CAAauC,EAAE,CAACE,KAAhB,CAA3C;AACH;;AACDzF,OAAO,CAAC2C,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA3C,OAAO,CAAC0C,UAAR,GAAqBC,QAArB,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASF,IAAT,CAAciD,MAAd,EAAsBC,MAAtB,EAA8B;EAC1B,OAAO,UAAUJ,EAAV,EAAc;IAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqBG,MAAM,EAA3B,GAAgCC,MAAM,CAACJ,EAAE,CAACtF,KAAJ,CAA9C;EAA4D,CAAnF;AACH;;AACDD,OAAO,CAACyC,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,UAAT,CAAoB+C,EAApB,EAAwB;EACpB,OAAOvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqB,IAArB,GAA4BA,EAAE,CAACtF,KAAtC;AACH;;AACDD,OAAO,CAACwC,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,WAAT,CAAqBgD,EAArB,EAAyB;EACrB,OAAOvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqBK,SAArB,GAAiCL,EAAE,CAACtF,KAA3C;AACH;;AACDD,OAAO,CAACuC,WAAR,GAAsBA,WAAtB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,UAAU,GAAG,UAAUoD,MAAV,EAAkB;EAAE,OAAO,UAAUH,EAAV,EAAc;IAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqBG,MAAM,EAA3B,GAAgCH,EAAE,CAACtF,KAA3C;EAAoD,CAA3E;AAA8E,CAAnH;;AACAD,OAAO,CAACsC,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAtC,OAAO,CAACqC,SAAR,GAAoBrC,OAAO,CAACsC,UAA5B,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASF,aAAT,CAAuBiD,CAAvB,EAA0B;EACtB,OAAO,YAAY;IACf,IAAIF,CAAC,GAAG,EAAR;;IACA,KAAK,IAAIU,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;MAC1CV,CAAC,CAACU,EAAD,CAAD,GAAQC,SAAS,CAACD,EAAD,CAAjB;IACH;;IACD,OAAO9C,YAAY,CAACsC,CAAC,CAACW,KAAF,CAAQ,KAAK,CAAb,EAAgBb,CAAhB,CAAD,CAAnB;EACH,CAND;AAOH;;AACDnF,OAAO,CAACoC,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;;AACApC,OAAO,CAACmC,WAAR,GAAsBD,cAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,cAAT,CAAwBmD,CAAxB,EAA2B;EACvB,OAAO,UAAUE,EAAV,EAAc;IAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqBvF,OAAO,CAACiD,IAA7B,GAAoCF,YAAY,CAACsC,CAAC,CAACE,EAAE,CAACtF,KAAJ,CAAF,CAAxD;EAAyE,CAAhG;AACH;;AACDD,OAAO,CAACkC,cAAR,GAAyBA,cAAzB,C,CACA;AACA;AACA;;AACA,IAAI+D,IAAI,GAAG,UAAUhB,EAAV,EAAcI,CAAd,EAAiB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACiC,GAAR,CAAYoD,CAAZ,CAApB,CAAP;AAA6C,CAA3E;;AACA,IAAIc,GAAG,GAAG,UAAUC,GAAV,EAAenB,EAAf,EAAmB;EAAE,OAAOF,UAAU,CAACmB,IAAX,CAAgBE,GAAhB,EAAqBpG,OAAO,CAACgC,EAAR,CAAWiD,EAAX,CAArB,CAAP;AAA8C,CAA7E;;AACA,IAAIoB,MAAM,GAAG,UAAUd,EAAV,EAAcF,CAAd,EAAiB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBX,EAAhB,EAAoBvF,OAAO,CAAC4B,KAAR,CAAcyD,CAAd,CAApB,CAAP;AAA+C,CAA/E;;AACA,IAAIiB,OAAO,GAAG,UAAUrB,EAAV,EAAcsB,CAAd,EAAiBlB,CAAjB,EAAoB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACmB,MAAR,CAAeoF,CAAf,EAAkBlB,CAAlB,CAApB,CAAP;AAAmD,CAAvF;;AACA,IAAImB,QAAQ,GAAG,UAAUC,CAAV,EAAa;EACxB,IAAIC,QAAQ,GAAG1G,OAAO,CAACkB,OAAR,CAAgBuF,CAAhB,CAAf;EACA,OAAO,UAAUxB,EAAV,EAAcI,CAAd,EAAiB;IAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoByB,QAAQ,CAACrB,CAAD,CAA5B,CAAP;EAA0C,CAApE;AACH,CAHD;;AAIA,IAAIsB,YAAY,GAAG,UAAU1B,EAAV,EAAcsB,CAAd,EAAiBlB,CAAjB,EAAoB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACiB,WAAR,CAAoBsF,CAApB,EAAuBlB,CAAvB,CAApB,CAAP;AAAwD,CAAjG;;AACA,IAAIuB,SAAS,GAAG,UAAUC,CAAV,EAAa;EACzB,IAAIC,SAAS,GAAG9G,OAAO,CAACU,QAAR,CAAiBmG,CAAjB,CAAhB;EACA,OAAO,UAAUE,EAAV,EAAc1B,CAAd,EAAiB;IAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBa,EAAhB,EAAoBD,SAAS,CAACzB,CAAD,CAA7B,CAAP;EAA2C,CAArE;AACH,CAHD;AAIA;;;AACA,IAAI2B,IAAI,GAAG,UAAU/B,EAAV,EAAcgC,IAAd,EAAoB;EAAE,OAAOlC,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACwB,GAAR,CAAYyF,IAAZ,CAApB,CAAP;AAAgD,CAAjF;;AACA,IAAIC,OAAO,GAAG,UAAUjC,EAAV,EAAcG,SAAd,EAAyB;EACnC,OAAOL,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACc,MAAR,CAAesE,SAAf,CAApB,CAAP;AACH,CAFD;AAGA;;;AACA,IAAI+B,UAAU,GAAG,UAAUlC,EAAV,EAAcI,CAAd,EAAiB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACa,SAAR,CAAkBwE,CAAlB,CAApB,CAAP;AAAmD,CAAvF;AACA;;;AACA,IAAI+B,OAAO,GAAG,UAAUC,EAAV,EAAchC,CAAd,EAAiB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBmB,EAAhB,EAAoBrH,OAAO,CAACqB,MAAR,CAAegE,CAAf,CAApB,CAAP;AAAgD,CAAjF;AACA;;;AACA,IAAIiC,UAAU,GAAG,UAAUrC,EAAV,EAAcG,SAAd,EAAyB;EAAE,OAAOL,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACY,SAAR,CAAkBwE,SAAlB,CAApB,CAAP;AAA2D,CAAvG;AACA;;;AACA,IAAImC,aAAa,GAAG,UAAUtC,EAAV,EAAcI,CAAd,EAAiB;EAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBjF,OAAO,CAACW,YAAR,CAAqB0E,CAArB,CAApB,CAAP;AAAsD,CAA7F;AACA;;;AACA,IAAImC,OAAO,GAAG,UAAUX,CAAV,EAAa;EACvB,IAAIY,OAAO,GAAGzH,OAAO,CAACQ,MAAR,CAAeqG,CAAf,CAAd;EACA,OAAO,UAAU5B,EAAV,EAAcI,CAAd,EAAiB;IAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoBwC,OAAO,CAACpC,CAAD,CAA3B,CAAP;EAAyC,CAAnE;AACH,CAHD;AAIA;;;AACA,IAAIqC,KAAK,GAAG,UAAUb,CAAV,EAAa;EACrB,IAAIc,KAAK,GAAG3H,OAAO,CAACO,IAAR,CAAasG,CAAb,CAAZ;EACA,OAAO,UAAU5B,EAAV,EAAcI,CAAd,EAAiB;IAAE,OAAON,UAAU,CAACmB,IAAX,CAAgBjB,EAAhB,EAAoB0C,KAAK,CAACtC,CAAD,CAAzB,CAAP;EAAuC,CAAjE;AACH,CAHD,C,CAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIpD,GAAG,GAAG,UAAUoD,CAAV,EAAa;EAAE,OAAO,UAAUJ,EAAV,EAAc;IAC1C,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBjF,OAAO,CAACiD,IAA7B,GAAoCjD,OAAO,CAACgD,IAAR,CAAaqC,CAAC,CAACJ,EAAE,CAAChF,KAAJ,CAAd,CAA3C;EACH,CAFwB;AAErB,CAFJ;;AAGAD,OAAO,CAACiC,GAAR,GAAcA,GAAd;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,EAAE,GAAG,UAAUiD,EAAV,EAAc;EAAE,OAAO,UAAUmB,GAAV,EAAe;IAC3C,OAAOpG,OAAO,CAACkD,MAAR,CAAekD,GAAf,IAAsBpG,OAAO,CAACiD,IAA9B,GAAqCjD,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBjF,OAAO,CAACiD,IAA7B,GAAoCjD,OAAO,CAACgD,IAAR,CAAaoD,GAAG,CAACnG,KAAJ,CAAUgF,EAAE,CAAChF,KAAb,CAAb,CAAhF;EACH,CAFwB;AAErB,CAFJ;;AAGAD,OAAO,CAACgC,EAAR,GAAaA,EAAb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,OAAO,GAAG,UAAU6F,EAAV,EAAc;EACxB,OAAO7C,UAAU,CAAC8C,IAAX,CAAgB7H,OAAO,CAACiC,GAAR,CAAY,UAAUkD,CAAV,EAAa;IAAE,OAAO,YAAY;MAAE,OAAOA,CAAP;IAAW,CAAhC;EAAmC,CAA9D,CAAhB,EAAiFnF,OAAO,CAACgC,EAAR,CAAW4F,EAAX,CAAjF,CAAP;AACH,CAFD;;AAGA5H,OAAO,CAAC+B,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,QAAQ,GAAG,UAAU8F,EAAV,EAAc;EACzB,OAAO7C,UAAU,CAAC8C,IAAX,CAAgB7H,OAAO,CAACiC,GAAR,CAAY,YAAY;IAAE,OAAO,UAAUsE,CAAV,EAAa;MAAE,OAAOA,CAAP;IAAW,CAAjC;EAAoC,CAA9D,CAAhB,EAAiFvG,OAAO,CAACgC,EAAR,CAAW4F,EAAX,CAAjF,CAAP;AACH,CAFD;;AAGA5H,OAAO,CAAC8B,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA9B,OAAO,CAAC6B,EAAR,GAAa7B,OAAO,CAACgD,IAArB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIpB,KAAK,GAAG,UAAUyD,CAAV,EAAa;EAAE,OAAO,UAAUE,EAAV,EAAc;IAC5C,OAAOvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqBvF,OAAO,CAACiD,IAA7B,GAAoCoC,CAAC,CAACE,EAAE,CAACtF,KAAJ,CAA5C;EACH,CAF0B;AAEvB,CAFJ;;AAGAD,OAAO,CAAC4B,KAAR,GAAgBA,KAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,UAAU,GAAG,UAAU0D,CAAV,EAAa;EAC1B,OAAOrF,OAAO,CAAC4B,KAAR,CAAc,UAAUuD,CAAV,EAAa;IAC9B,OAAOJ,UAAU,CAACmB,IAAX,CAAgBb,CAAC,CAACF,CAAD,CAAjB,EAAsBnF,OAAO,CAACiC,GAAR,CAAY,YAAY;MAAE,OAAOkD,CAAP;IAAW,CAArC,CAAtB,CAAP;EACH,CAFM,CAAP;AAGH,CAJD;;AAKAnF,OAAO,CAAC2B,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA3B,OAAO,CAAC0B,OAAR,GACA,aACA1B,OAAO,CAAC4B,KAAR,CAAcmD,UAAU,CAAC+C,QAAzB,CAFA;AAGA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIrG,IAAI,GAAG,UAAUwF,IAAV,EAAgB;EAAE,OAAO,UAAUhC,EAAV,EAAc;IAC9C,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBgC,IAAI,EAAzB,GAA8BhC,EAArC;EACH,CAF4B;AAEzB,CAFJ;;AAGAjF,OAAO,CAACyB,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAzB,OAAO,CAACwB,GAAR,GAAcxB,OAAO,CAACyB,IAAtB;AACA;AACA;AACA;AACA;;AACA,IAAIF,IAAI,GAAG,YAAY;EAAE,OAAOvB,OAAO,CAACiD,IAAf;AAAsB,CAA/C;;AACAjD,OAAO,CAACuB,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;;AACA,IAAID,UAAU,GAAG,YAAY;EAAE,OAAOtB,OAAO,CAACiD,IAAf;AAAsB,CAArD;;AACAjD,OAAO,CAACsB,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;;AACA,IAAID,MAAM,GAAG,UAAUgE,CAAV,EAAa;EAAE,OAAO,UAAUgC,EAAV,EAAc;IAC7C,OAAOrH,OAAO,CAACkD,MAAR,CAAemE,EAAf,IAAqBrH,OAAO,CAACiD,IAA7B,GAAoCjD,OAAO,CAACgD,IAAR,CAAaqC,CAAC,CAACgC,EAAD,CAAd,CAA3C;EACH,CAF2B;AAExB,CAFJ;;AAGArH,OAAO,CAACqB,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;AACA;AACA;;AACArB,OAAO,CAACoB,SAAR,GACA,aACApB,OAAO,CAACqB,MAAR,CAAe0D,UAAU,CAAC+C,QAA1B,CAFA;AAGA;AACA;AACA;AACA;;AACA,IAAI3G,MAAM,GAAG,UAAUoF,CAAV,EAAalB,CAAb,EAAgB;EAAE,OAAO,UAAUJ,EAAV,EAAc;IAChD,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBsB,CAArB,GAAyBlB,CAAC,CAACkB,CAAD,EAAItB,EAAE,CAAChF,KAAP,CAAjC;EACH,CAF8B;AAE3B,CAFJ;;AAGAD,OAAO,CAACmB,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;;AACA,IAAID,OAAO,GAAG,UAAUuF,CAAV,EAAa;EAAE,OAAO,UAAUpB,CAAV,EAAa;IAAE,OAAO,UAAUJ,EAAV,EAAc;MACpE,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBwB,CAAC,CAACsB,KAAvB,GAA+B1C,CAAC,CAACJ,EAAE,CAAChF,KAAJ,CAAvC;IACH,CAFkD;EAE/C,CAFyB;AAEtB,CAFP;;AAGAD,OAAO,CAACkB,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;;AACA,IAAID,WAAW,GAAG,UAAUsF,CAAV,EAAalB,CAAb,EAAgB;EAAE,OAAO,UAAUJ,EAAV,EAAc;IACrD,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBsB,CAArB,GAAyBlB,CAAC,CAACJ,EAAE,CAAChF,KAAJ,EAAWsG,CAAX,CAAjC;EACH,CAFmC;AAEhC,CAFJ;;AAGAvG,OAAO,CAACiB,WAAR,GAAsBA,WAAtB;AACA;AACA;AACA;AACA;;AACAjB,OAAO,CAACgB,OAAR,GAAkBhB,OAAO,CAAC0B,OAA1B;AACA,IAAIsG,eAAe,GAAG;EAAExC,IAAI,EAAExF,OAAO,CAACiD,IAAhB;EAAsBwC,KAAK,EAAEzF,OAAO,CAACiD;AAArC,CAAtB;AACA;AACA;AACA;AACA;;AACA,IAAIlC,QAAQ,GAAG,UAAUwE,EAAV,EAAc;EACzB,IAAI0C,CAAC,GAAGlD,UAAU,CAACmB,IAAX,CAAgBX,EAAhB,EAAoBvF,OAAO,CAACiC,GAAR,CAAY,UAAUqD,CAAV,EAAa;IAAE,OAAQ;MAC3DE,IAAI,EAAE5C,OAAO,CAAC0C,CAAD,CAD8C;MAE3DG,KAAK,EAAE9C,QAAQ,CAAC2C,CAAD;IAF4C,CAAR;EAGlD,CAHuB,CAApB,CAAR;EAIA,OAAOtF,OAAO,CAACkD,MAAR,CAAe+E,CAAf,IAAoBD,eAApB,GAAsCC,CAAC,CAAChI,KAA/C;AACH,CAND;;AAOAD,OAAO,CAACe,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;;AACA,IAAID,MAAM,GAAG,UAAUsE,SAAV,EAAqB;EAAE,OAAO,UAAUH,EAAV,EAAc;IAAE,OAAQjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBjF,OAAO,CAACiD,IAA7B,GAAoCmC,SAAS,CAACH,EAAE,CAAChF,KAAJ,CAAT,GAAsBgF,EAAtB,GAA2BjF,OAAO,CAACiD,IAA/E;EAAuF,CAA9G;AAAiH,CAArJ;;AACAjD,OAAO,CAACc,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;;AACA,IAAID,SAAS,GAAG,UAAUwE,CAAV,EAAa;EAAE,OAAO,UAAUJ,EAAV,EAAc;IAChD,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqBjF,OAAO,CAACiD,IAA7B,GAAoCoC,CAAC,CAACJ,EAAE,CAAChF,KAAJ,CAA5C;EACH,CAF8B;AAE3B,CAFJ;;AAGAD,OAAO,CAACa,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;;AACA,IAAID,SAAS,GAAG,UAAUwE,SAAV,EAAqB;EAAE,OAAO,UAAUH,EAAV,EAAc;IACxD,OAAO;MACHO,IAAI,EAAE0B,OAAO,CAACjC,EAAD,EAAK,UAAUE,CAAV,EAAa;QAAE,OAAO,CAACC,SAAS,CAACD,CAAD,CAAjB;MAAuB,CAA3C,CADV;MAEHM,KAAK,EAAEyB,OAAO,CAACjC,EAAD,EAAKG,SAAL;IAFX,CAAP;EAIH,CALsC;AAKnC,CALJ;;AAMApF,OAAO,CAACY,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;;AACA,IAAID,YAAY,GAAG,UAAU0E,CAAV,EAAa;EAAE,OAAON,UAAU,CAAC8C,IAAX,CAAgB7H,OAAO,CAACiC,GAAR,CAAYoD,CAAZ,CAAhB,EAAgCrF,OAAO,CAACe,QAAxC,CAAP;AAA2D,CAA7F;;AACAf,OAAO,CAACW,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;;AACA,IAAID,QAAQ,GAAG,UAAUmG,CAAV,EAAa;EAAE,OAAO,UAAUxB,CAAV,EAAa;IAAE,OAAO,UAAU0B,EAAV,EAAc;MAAE,OAAQ/G,OAAO,CAACkD,MAAR,CAAe6D,EAAf,IAAqBF,CAAC,CAAChF,EAAF,CAAK7B,OAAO,CAACiD,IAAb,CAArB,GAA0C4D,CAAC,CAAC5E,GAAF,CAAMoD,CAAC,CAAC0B,EAAE,CAAC9G,KAAJ,CAAP,EAAmBD,OAAO,CAACgD,IAA3B,CAAlD;IAAsF,CAA7G;EAAgH,CAAtI;AAAyI,CAAvK;;AACAhD,OAAO,CAACU,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;;AACA,IAAID,QAAQ,GAAG,UAAUoG,CAAV,EAAa;EAAE,OAAO,UAAUE,EAAV,EAAc;IAAE,OAAQ/G,OAAO,CAACkD,MAAR,CAAe6D,EAAf,IAAqBF,CAAC,CAAChF,EAAF,CAAK7B,OAAO,CAACiD,IAAb,CAArB,GAA0C4D,CAAC,CAAC5E,GAAF,CAAM8E,EAAE,CAAC9G,KAAT,EAAgBD,OAAO,CAACgD,IAAxB,CAAlD;EAAmF,CAA1G;AAA6G,CAA3I;;AACAhD,OAAO,CAACS,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;;AACA,IAAID,MAAM,GAAG,UAAUqG,CAAV,EAAa;EAAE,OAAO,UAAUxB,CAAV,EAAa;IAAE,OAAO,UAAUJ,EAAV,EAAc;MAAE,OAAQjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IAAqB4B,CAAC,CAAChF,EAAF,CAAK7B,OAAO,CAACiD,IAAb,CAArB,GAA0CoC,CAAC,CAACJ,EAAE,CAAChF,KAAJ,CAAnD;IAAiE,CAAxF;EAA2F,CAAjH;AAAoH,CAAhJ;;AACAD,OAAO,CAACQ,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;;AACA,IAAID,IAAI,GAAG,UAAUsG,CAAV,EAAa;EAAE,OAAO,UAAUxB,CAAV,EAAa;IAAE,OAAO,UAAUJ,EAAV,EAAc;MACjE,OAAOjF,OAAO,CAACkD,MAAR,CAAe+B,EAAf,IACD4B,CAAC,CAAChF,EAAF,CAAK;QACH2D,IAAI,EAAExF,OAAO,CAACiD,IADX;QAEHwC,KAAK,EAAEzF,OAAO,CAACiD;MAFZ,CAAL,CADC,GAKD4D,CAAC,CAAC5E,GAAF,CAAMoD,CAAC,CAACJ,EAAE,CAAChF,KAAJ,CAAP,EAAmB,UAAUqF,CAAV,EAAa;QAAE,OAAQ;UACxCE,IAAI,EAAE5C,OAAO,CAAC0C,CAAD,CAD2B;UAExCG,KAAK,EAAE9C,QAAQ,CAAC2C,CAAD;QAFyB,CAAR;MAG/B,CAHH,CALN;IASH,CAV+C;EAU5C,CAVsB;AAUnB,CAVP;;AAWAtF,OAAO,CAACO,IAAR,GAAeA,IAAf,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACAP,OAAO,CAACM,GAAR,GAAc,QAAd;AACA;AACA;AACA;AACA;;AACA,SAASD,OAAT,CAAiB6H,CAAjB,EAAoB;EAChB,OAAO;IACHC,IAAI,EAAE,UAAU5C,EAAV,EAAc;MAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqB,MAArB,GAA8B,UAAU2C,CAAC,CAACC,IAAF,CAAO5C,EAAE,CAACtF,KAAV,CAAV,GAA6B,GAAnE;IAA0E;EAD7F,CAAP;AAGH;;AACDD,OAAO,CAACK,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,KAAT,CAAegI,CAAf,EAAkB;EACd,OAAO;IACHC,MAAM,EAAE,UAAUC,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAOD,CAAC,KAAKC,CAAN,KAAYvI,OAAO,CAACkD,MAAR,CAAeoF,CAAf,IAAoBtI,OAAO,CAACkD,MAAR,CAAeqF,CAAf,CAApB,GAAwCvI,OAAO,CAACkD,MAAR,CAAeqF,CAAf,IAAoB,KAApB,GAA4BH,CAAC,CAACC,MAAF,CAASC,CAAC,CAACrI,KAAX,EAAkBsI,CAAC,CAACtI,KAApB,CAAhF,CAAP;IAAqH;EAD5I,CAAP;AAGH;;AACDD,OAAO,CAACI,KAAR,GAAgBA,KAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,MAAT,CAAgBqI,CAAhB,EAAmB;EACf,OAAO;IACHH,MAAM,EAAEjI,KAAK,CAACoI,CAAD,CAAL,CAASH,MADd;IAEHI,OAAO,EAAE,UAAUH,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAQD,CAAC,KAAKC,CAAN,GAAU,CAAV,GAAcvI,OAAO,CAACmD,MAAR,CAAemF,CAAf,IAAqBtI,OAAO,CAACmD,MAAR,CAAeoF,CAAf,IAAoBC,CAAC,CAACC,OAAF,CAAUH,CAAC,CAACrI,KAAZ,EAAmBsI,CAAC,CAACtI,KAArB,CAApB,GAAkD,CAAvE,GAA4E,CAAC,CAAnG;IAAwG;EAFhI,CAAP;AAIH;;AACDD,OAAO,CAACG,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,iBAAT,CAA2BgI,CAA3B,EAA8B;EAC1B,OAAO;IACHQ,MAAM,EAAE,UAAUJ,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAQvI,OAAO,CAACmD,MAAR,CAAemF,CAAf,KAAqBtI,OAAO,CAACmD,MAAR,CAAeoF,CAAf,CAArB,GAAyCvI,OAAO,CAACgD,IAAR,CAAakF,CAAC,CAACQ,MAAF,CAASJ,CAAC,CAACrI,KAAX,EAAkBsI,CAAC,CAACtI,KAApB,CAAb,CAAzC,GAAoFD,OAAO,CAACiD,IAApG;IAA4G;EADnI,CAAP;AAGH;;AACDjD,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;;AACA,SAAS4E,cAAT,CAAwB2B,CAAxB,EAA2B;EACvB,OAAO;IACHiC,MAAM,EAAExI,iBAAiB,CAACuG,CAAD,CAAjB,CAAqBiC,MAD1B;IAEHX,KAAK,EAAE/H,OAAO,CAACgD,IAAR,CAAayD,CAAC,CAACsB,KAAf;EAFJ,CAAP;AAIH;;AACD/H,OAAO,CAAC8E,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,cAAT,GAA0B;EACtB,OAAO;IACH6D,MAAM,EAAE,UAAUJ,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAQvI,OAAO,CAACkD,MAAR,CAAeoF,CAAf,IAAoBC,CAApB,GAAwBD,CAAhC;IAAqC,CAD5D;IAEHP,KAAK,EAAE/H,OAAO,CAACiD;EAFZ,CAAP;AAIH;;AACDjD,OAAO,CAAC6E,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,aAAT,GAAyB;EACrB,OAAO;IACH8D,MAAM,EAAE,UAAUJ,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAQvI,OAAO,CAACkD,MAAR,CAAeqF,CAAf,IAAoBD,CAApB,GAAwBC,CAAhC;IAAqC,CAD5D;IAEHR,KAAK,EAAE/H,OAAO,CAACiD;EAFZ,CAAP;AAIH;;AACDjD,OAAO,CAAC4E,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,SAAT,CAAmBuD,CAAnB,EAAsB;EAClB,OAAO;IACHQ,MAAM,EAAE,UAAUJ,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAQvI,OAAO,CAACkD,MAAR,CAAeoF,CAAf,IAAoBC,CAApB,GAAwBvI,OAAO,CAACkD,MAAR,CAAeqF,CAAf,IAAoBD,CAApB,GAAwBtI,OAAO,CAACgD,IAAR,CAAakF,CAAC,CAACQ,MAAF,CAASJ,CAAC,CAACrI,KAAX,EAAkBsI,CAAC,CAACtI,KAApB,CAAb,CAAxD;IAAoG,CAD3H;IAEH8H,KAAK,EAAE/H,OAAO,CAACiD;EAFZ,CAAP;AAIH;;AACDjD,OAAO,CAAC2E,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;;AACA3E,OAAO,CAAC0E,OAAR,GAAkB;EACdpE,GAAG,EAAEN,OAAO,CAACM,GADC;EAEd2B,GAAG,EAAEgE;AAFS,CAAlB;AAIA;AACA;AACA;AACA;;AACAjG,OAAO,CAACyE,WAAR,GAAsB;EAClBnE,GAAG,EAAEN,OAAO,CAACM,GADK;EAElB2B,GAAG,EAAEgE,IAFa;EAGlBjE,EAAE,EAAEmE,GAHc;EAIlBtE,EAAE,EAAE7B,OAAO,CAAC6B;AAJM,CAAtB;AAMA;AACA;AACA;AACA;;AACA7B,OAAO,CAACwE,KAAR,GAAgB;EACZlE,GAAG,EAAEN,OAAO,CAACM,GADD;EAEZ2B,GAAG,EAAEgE,IAFO;EAGZjE,EAAE,EAAEmE,GAHQ;EAIZtE,EAAE,EAAE7B,OAAO,CAAC6B,EAJA;EAKZD,KAAK,EAAEyE;AALK,CAAhB;AAOA;AACA;AACA;AACA;;AACArG,OAAO,CAACuE,QAAR,GAAmB;EACfjE,GAAG,EAAEN,OAAO,CAACM,GADE;EAEfa,MAAM,EAAEmF,OAFO;EAGfpF,OAAO,EAAEsF,QAHM;EAIfvF,WAAW,EAAE0F;AAJE,CAAnB;AAMA;AACA;AACA;AACA;;AACA3G,OAAO,CAACsE,GAAR,GAAc;EACVhE,GAAG,EAAEN,OAAO,CAACM,GADH;EAEV2B,GAAG,EAAEgE,IAFK;EAGVzE,GAAG,EAAEwF;AAHK,CAAd;AAKA;AACA;AACA;AACA;;AACAhH,OAAO,CAACqE,WAAR,GAAsB;EAClB/D,GAAG,EAAEN,OAAO,CAACM,GADK;EAElB2B,GAAG,EAAEgE,IAFa;EAGlBjE,EAAE,EAAEmE,GAHc;EAIlBtE,EAAE,EAAE7B,OAAO,CAAC6B,EAJM;EAKlBL,GAAG,EAAEwF,IALa;EAMlBzF,IAAI,EAAEvB,OAAO,CAACuB;AANI,CAAtB;AAQA;AACA;AACA;AACA;;AACAvB,OAAO,CAACoE,MAAR,GAAiB;EACb9D,GAAG,EAAEN,OAAO,CAACM,GADA;EAEb2B,GAAG,EAAEgE,IAFQ;EAGb5E,MAAM,EAAE+F;AAHK,CAAjB;AAKA;AACA;AACA;AACA;;AACApH,OAAO,CAACmE,WAAR,GAAsB;EAClB7D,GAAG,EAAEN,OAAO,CAACM,GADK;EAElBU,OAAO,EAAEhB,OAAO,CAACgB,OAFC;EAGlBD,QAAQ,EAAEf,OAAO,CAACe;AAHA,CAAtB;AAKA;AACA;AACA;AACA;;AACAf,OAAO,CAACkE,UAAR,GAAqB;EACjB5D,GAAG,EAAEN,OAAO,CAACM,GADI;EAEjB2B,GAAG,EAAEgE,IAFY;EAGjBjF,OAAO,EAAEhB,OAAO,CAACgB,OAHA;EAIjBD,QAAQ,EAAEf,OAAO,CAACe,QAJD;EAKjBD,MAAM,EAAEoG,OALS;EAMjBrG,SAAS,EAAEsG,UANM;EAOjBvG,SAAS,EAAE0G,UAPM;EAQjB3G,YAAY,EAAE4G;AARG,CAArB;AAUA;AACA;AACA;AACA;;AACAvH,OAAO,CAACiE,WAAR,GAAsB;EAClB3D,GAAG,EAAEN,OAAO,CAACM,GADK;EAElB2B,GAAG,EAAEgE,IAFa;EAGlB9E,MAAM,EAAEmF,OAHU;EAIlBpF,OAAO,EAAEsF,QAJS;EAKlBvF,WAAW,EAAE0F,YALK;EAMlBjG,QAAQ,EAAEkG,SANQ;EAOlBnG,QAAQ,EAAET,OAAO,CAACS;AAPA,CAAtB;AASA;AACA;AACA;AACA;;AACAT,OAAO,CAACgE,UAAR,GAAqB;EACjB1D,GAAG,EAAEN,OAAO,CAACM,GADI;EAEjB2B,GAAG,EAAEgE,IAFY;EAGjB9E,MAAM,EAAEmF,OAHS;EAIjBpF,OAAO,EAAEsF,QAJQ;EAKjBvF,WAAW,EAAE0F,YALI;EAMjBjG,QAAQ,EAAEkG,SANO;EAOjBnG,QAAQ,EAAET,OAAO,CAACS,QAPD;EAQjBO,OAAO,EAAEhB,OAAO,CAACgB,OARA;EASjBD,QAAQ,EAAEf,OAAO,CAACe,QATD;EAUjBD,MAAM,EAAEoG,OAVS;EAWjBrG,SAAS,EAAEsG,UAXM;EAYjBvG,SAAS,EAAE0G,UAZM;EAajB3G,YAAY,EAAE4G,aAbG;EAcjB/G,MAAM,EAAEgH,OAdS;EAejBjH,IAAI,EAAEmH;AAfW,CAArB;AAiBA;AACA;AACA;AACA;;AACA1H,OAAO,CAAC+D,UAAR,GAAqB;EACjBzD,GAAG,EAAEN,OAAO,CAACM,GADI;EAEjB2B,GAAG,EAAEgE,IAFY;EAGjBjE,EAAE,EAAEmE,GAHa;EAIjBtE,EAAE,EAAE7B,OAAO,CAAC6B,EAJK;EAKjBD,KAAK,EAAEyE,MALU;EAMjB/E,UAAU,EAAEtB,OAAO,CAACsB;AANH,CAArB,C,CAQA;;AACA;AACA;AACA;AACA;;AACAtB,OAAO,CAAC8D,MAAR,GAAiB;EACbxD,GAAG,EAAEN,OAAO,CAACM,GADA;EAEb2B,GAAG,EAAEgE,IAFQ;EAGbpE,EAAE,EAAE7B,OAAO,CAAC6B,EAHC;EAIbG,EAAE,EAAEmE,GAJS;EAKbvE,KAAK,EAAEyE,MALM;EAMblF,MAAM,EAAEmF,OANK;EAObpF,OAAO,EAAEsF,QAPI;EAQbvF,WAAW,EAAE0F,YARA;EASbjG,QAAQ,EAAEkG,SATG;EAUbnG,QAAQ,EAAET,OAAO,CAACS,QAVL;EAWbc,IAAI,EAAEvB,OAAO,CAACuB,IAXD;EAYbC,GAAG,EAAEwF,IAZQ;EAab3F,MAAM,EAAE+F,OAbK;EAcbpG,OAAO,EAAEhB,OAAO,CAACgB,OAdJ;EAebD,QAAQ,EAAEf,OAAO,CAACe,QAfL;EAgBbD,MAAM,EAAEoG,OAhBK;EAiBbrG,SAAS,EAAEsG,UAjBE;EAkBbvG,SAAS,EAAE0G,UAlBE;EAmBb3G,YAAY,EAAE4G,aAnBD;EAoBb/G,MAAM,EAAEgH,OApBK;EAqBbjH,IAAI,EAAEmH,KArBO;EAsBbpG,UAAU,EAAEtB,OAAO,CAACsB;AAtBP,CAAjB,C,CAwBA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASuC,IAAT,CAAcuE,CAAd,EAAiB;EACb,OAAO,UAAUjD,CAAV,EAAaI,EAAb,EAAiB;IAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqB,KAArB,GAA6B6C,CAAC,CAACC,MAAF,CAASlD,CAAT,EAAYI,EAAE,CAACtF,KAAf,CAArC;EAA8D,CAAxF;AACH;;AACDD,OAAO,CAAC6D,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,MAAT,CAAgBwB,SAAhB,EAA2B;EACvB,OAAO,UAAUG,EAAV,EAAc;IAAE,OAAQvF,OAAO,CAACkD,MAAR,CAAeqC,EAAf,IAAqB,KAArB,GAA6BH,SAAS,CAACG,EAAE,CAACtF,KAAJ,CAA9C;EAA4D,CAAnF;AACH;;AACDD,OAAO,CAAC4D,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,aAAT,CAAuBgF,SAAvB,EAAkC;EAC9B,OAAO,UAAUxD,CAAV,EAAa;IAAE,OAAOnF,OAAO,CAACmD,MAAR,CAAewF,SAAS,CAACxD,CAAD,CAAxB,CAAP;EAAsC,CAA5D;AACH;;AACDnF,OAAO,CAAC2D,aAAR,GAAwBA,aAAxB,C,CACA;AACA;AACA;;AACA;AACA;AACA;;AACA3D,OAAO,CAAC0D,EAAR,GACA,aACA1D,OAAO,CAAC6B,EAAR,CAAW,EAAX,CAFA;AAGA;AACA;AACA;;AACA,IAAI4B,MAAM,GAAG,UAAUmF,IAAV,EAAgB;EAAE,OAAO5I,OAAO,CAACiC,GAAR,CAAY8C,UAAU,CAAC8D,OAAX,CAAmBD,IAAnB,CAAZ,CAAP;AAA+C,CAA9E;;AACA5I,OAAO,CAACyD,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;;AACA,IAAID,IAAI,GAAG,UAAUoF,IAAV,EAAgBvD,CAAhB,EAAmB;EAC1B,OAAOrF,OAAO,CAAC4B,KAAR,CAAc,UAAUuD,CAAV,EAAa;IAC9B,OAAOJ,UAAU,CAACmB,IAAX,CAAgBb,CAAC,CAACF,CAAD,CAAjB,EAAsBnF,OAAO,CAACiC,GAAR,CAAY,UAAUsE,CAAV,EAAa;MAAE,OAAOxB,UAAU,CAAC+D,KAAX,CAAiB3D,CAAjB,EAAoByD,IAApB,EAA0BrC,CAA1B,CAAP;IAAsC,CAAjE,CAAtB,CAAP;EACH,CAFM,CAAP;AAGH,CAJD;;AAKAvG,OAAO,CAACwD,IAAR,GAAeA,IAAf,C,CACA;AACA;AACA;;AACA;AACA;AACA;;AACA,IAAID,GAAG,GAAG,UAAUqF,IAAV,EAAgBhB,EAAhB,EAAoB;EAC1B,OAAO7C,UAAU,CAAC8C,IAAX,CAAgB7H,OAAO,CAACiC,GAAR,CAAY,UAAUkD,CAAV,EAAa;IAAE,OAAO,UAAUoB,CAAV,EAAa;MAAE,OAAOxB,UAAU,CAAC+D,KAAX,CAAiB3D,CAAjB,EAAoByD,IAApB,EAA0BrC,CAA1B,CAAP;IAAsC,CAA5D;EAA+D,CAA1F,CAAhB,EAA6GvG,OAAO,CAACgC,EAAR,CAAW4F,EAAX,CAA7G,CAAP;AACH,CAFD;;AAGA5H,OAAO,CAACuD,GAAR,GAAcA,GAAd,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA,IAAID,sBAAsB,GAAG,UAAU+B,CAAV,EAAa;EAAE,OAAO,UAAU0D,GAAV,EAAe;IAC9D;IACA,IAAIC,MAAM,GAAG,EAAb;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAAChD,MAAxB,EAAgCkD,CAAC,EAAjC,EAAqC;MACjC,IAAI1C,CAAC,GAAGlB,CAAC,CAAC4D,CAAD,EAAIF,GAAG,CAACE,CAAD,CAAP,CAAT;;MACA,IAAIjJ,OAAO,CAACkD,MAAR,CAAeqD,CAAf,CAAJ,EAAuB;QACnB,OAAOvG,OAAO,CAACiD,IAAf;MACH;;MACD+F,MAAM,CAACE,IAAP,CAAY3C,CAAC,CAACtG,KAAd;IACH;;IACD,OAAOD,OAAO,CAACgD,IAAR,CAAagG,MAAb,CAAP;EACH,CAX2C;AAWxC,CAXJ;;AAYAhJ,OAAO,CAACsD,sBAAR,GAAiCA,sBAAjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,aAAa,GAAG,UAAUgC,CAAV,EAAa;EAAE,OAAOrF,OAAO,CAACsD,sBAAR,CAA+B,UAAU6F,CAAV,EAAahE,CAAb,EAAgB;IAAE,OAAOE,CAAC,CAACF,CAAD,CAAR;EAAc,CAA/D,CAAP;AAA0E,CAA7G;;AACAnF,OAAO,CAACqD,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACArD,OAAO,CAACoD,aAAR,GACA,aACApD,OAAO,CAACqD,aAAR,CAAsB0B,UAAU,CAAC+C,QAAjC,CAFA"},"metadata":{},"sourceType":"script"}