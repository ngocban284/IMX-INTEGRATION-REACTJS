{"ast":null,"code":"import { identity, pipe, bind_, bindTo_, flow } from './function'; // -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\n\nexport var isSome = function (fa) {\n  return fa._tag === 'Some';\n};\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\n\nexport var isNone = function (fa) {\n  return fa._tag === 'None';\n}; // -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport var none = {\n  _tag: 'None'\n};\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport var some = function (a) {\n  return {\n    _tag: 'Some',\n    value: a\n  };\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport function fromNullable(a) {\n  return a == null ? none : some(a);\n}\nexport function fromPredicate(predicate) {\n  return function (a) {\n    return predicate(a) ? some(a) : none;\n  };\n}\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport function tryCatch(f) {\n  try {\n    return some(f());\n  } catch (e) {\n    return none;\n  }\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport function getLeft(ma) {\n  return ma._tag === 'Right' ? none : some(ma.left);\n}\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport function getRight(ma) {\n  return ma._tag === 'Left' ? none : some(ma.right);\n}\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\n\nexport var fromEither = getRight; // -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nexport function fold(onNone, onSome) {\n  return function (ma) {\n    return isNone(ma) ? onNone() : onSome(ma.value);\n  };\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nexport function toNullable(ma) {\n  return isNone(ma) ? null : ma.value;\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nexport function toUndefined(ma) {\n  return isNone(ma) ? undefined : ma.value;\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\n\nexport var getOrElseW = function (onNone) {\n  return function (ma) {\n    return isNone(ma) ? onNone() : ma.value;\n  };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\n\nexport var getOrElse = getOrElseW; // -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\n\nexport function fromNullableK(f) {\n  return function () {\n    var a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      a[_i] = arguments[_i];\n    }\n\n    return fromNullable(f.apply(void 0, a));\n  };\n}\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\n\nexport var mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\n\nexport function chainNullableK(f) {\n  return function (ma) {\n    return isNone(ma) ? none : fromNullable(f(ma.value));\n  };\n} // -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\n\nvar map_ = function (fa, f) {\n  return pipe(fa, map(f));\n};\n\nvar ap_ = function (fab, fa) {\n  return pipe(fab, ap(fa));\n};\n\nvar chain_ = function (ma, f) {\n  return pipe(ma, chain(f));\n};\n\nvar reduce_ = function (fa, b, f) {\n  return pipe(fa, reduce(b, f));\n};\n\nvar foldMap_ = function (M) {\n  var foldMapM = foldMap(M);\n  return function (fa, f) {\n    return pipe(fa, foldMapM(f));\n  };\n};\n\nvar reduceRight_ = function (fa, b, f) {\n  return pipe(fa, reduceRight(b, f));\n};\n\nvar traverse_ = function (F) {\n  var traverseF = traverse(F);\n  return function (ta, f) {\n    return pipe(ta, traverseF(f));\n  };\n};\n/* istanbul ignore next */\n\n\nvar alt_ = function (fa, that) {\n  return pipe(fa, alt(that));\n};\n\nvar filter_ = function (fa, predicate) {\n  return pipe(fa, filter(predicate));\n};\n/* istanbul ignore next */\n\n\nvar filterMap_ = function (fa, f) {\n  return pipe(fa, filterMap(f));\n};\n/* istanbul ignore next */\n\n\nvar extend_ = function (wa, f) {\n  return pipe(wa, extend(f));\n};\n/* istanbul ignore next */\n\n\nvar partition_ = function (fa, predicate) {\n  return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\n\n\nvar partitionMap_ = function (fa, f) {\n  return pipe(fa, partitionMap(f));\n};\n/* istanbul ignore next */\n\n\nvar wither_ = function (F) {\n  var witherF = wither(F);\n  return function (fa, f) {\n    return pipe(fa, witherF(f));\n  };\n};\n/* istanbul ignore next */\n\n\nvar wilt_ = function (F) {\n  var wiltF = wilt(F);\n  return function (fa, f) {\n    return pipe(fa, wiltF(f));\n  };\n}; // -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\n\n\nexport var map = function (f) {\n  return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n  };\n};\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\n\nexport var ap = function (fa) {\n  return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n  };\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport var apFirst = function (fb) {\n  return flow(map(function (a) {\n    return function () {\n      return a;\n    };\n  }), ap(fb));\n};\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport var apSecond = function (fb) {\n  return flow(map(function () {\n    return function (b) {\n      return b;\n    };\n  }), ap(fb));\n};\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\n\nexport var of = some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\n\nexport var chain = function (f) {\n  return function (ma) {\n    return isNone(ma) ? none : f(ma.value);\n  };\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport var chainFirst = function (f) {\n  return chain(function (a) {\n    return pipe(f(a), map(function () {\n      return a;\n    }));\n  });\n};\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport var flatten = /*#__PURE__*/chain(identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\n\nexport var altW = function (that) {\n  return function (fa) {\n    return isNone(fa) ? that() : fa;\n  };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\n\nexport var alt = altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\n\nexport var zero = function () {\n  return none;\n};\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\n\nexport var throwError = function () {\n  return none;\n};\n/**\n * @category Extend\n * @since 2.0.0\n */\n\nexport var extend = function (f) {\n  return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n  };\n};\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport var duplicate = /*#__PURE__*/extend(identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nexport var reduce = function (b, f) {\n  return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n  };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nexport var foldMap = function (M) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? M.empty : f(fa.value);\n    };\n  };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\n\nexport var reduceRight = function (b, f) {\n  return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n  };\n};\n/**\n * @category Compactable\n * @since 2.0.0\n */\n\nexport var compact = flatten;\nvar defaultSeparate = {\n  left: none,\n  right: none\n};\n/**\n * @category Compactable\n * @since 2.0.0\n */\n\nexport var separate = function (ma) {\n  var o = pipe(ma, map(function (e) {\n    return {\n      left: getLeft(e),\n      right: getRight(e)\n    };\n  }));\n  return isNone(o) ? defaultSeparate : o.value;\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nexport var filter = function (predicate) {\n  return function (fa) {\n    return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nexport var filterMap = function (f) {\n  return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nexport var partition = function (predicate) {\n  return function (fa) {\n    return {\n      left: filter_(fa, function (a) {\n        return !predicate(a);\n      }),\n      right: filter_(fa, predicate)\n    };\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\n\nexport var partitionMap = function (f) {\n  return flow(map(f), separate);\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\n\nexport var traverse = function (F) {\n  return function (f) {\n    return function (ta) {\n      return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n    };\n  };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\n\nexport var sequence = function (F) {\n  return function (ta) {\n    return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n  };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\n\nexport var wither = function (F) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? F.of(none) : f(fa.value);\n    };\n  };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\n\nexport var wilt = function (F) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? F.of({\n        left: none,\n        right: none\n      }) : F.map(f(fa.value), function (e) {\n        return {\n          left: getLeft(e),\n          right: getRight(e)\n        };\n      });\n    };\n  };\n}; // -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexport function getShow(S) {\n  return {\n    show: function (ma) {\n      return isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\";\n    }\n  };\n}\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getEq(E) {\n  return {\n    equals: function (x, y) {\n      return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value));\n    }\n  };\n}\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getOrd(O) {\n  return {\n    equals: getEq(O).equals,\n    compare: function (x, y) {\n      return x === y ? 0 : isSome(x) ? isSome(y) ? O.compare(x.value, y.value) : 1 : -1;\n    }\n  };\n}\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getApplySemigroup(S) {\n  return {\n    concat: function (x, y) {\n      return isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none;\n    }\n  };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexport function getApplyMonoid(M) {\n  return {\n    concat: getApplySemigroup(M).concat,\n    empty: some(M.empty)\n  };\n}\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getFirstMonoid() {\n  return {\n    concat: function (x, y) {\n      return isNone(x) ? y : x;\n    },\n    empty: none\n  };\n}\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getLastMonoid() {\n  return {\n    concat: function (x, y) {\n      return isNone(y) ? x : y;\n    },\n    empty: none\n  };\n}\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getMonoid(S) {\n  return {\n    concat: function (x, y) {\n      return isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value));\n    },\n    empty: none\n  };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Functor = {\n  URI: URI,\n  map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Applicative = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Monad = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Foldable = {\n  URI: URI,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Alt = {\n  URI: URI,\n  map: map_,\n  alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Alternative = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  alt: alt_,\n  zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Extend = {\n  URI: URI,\n  map: map_,\n  extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Compactable = {\n  URI: URI,\n  compact: compact,\n  separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Filterable = {\n  URI: URI,\n  map: map_,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Traversable = {\n  URI: URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var Witherable = {\n  URI: URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\n\nexport var MonadThrow = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  chain: chain_,\n  throwError: throwError\n}; // TODO: remove in v3\n\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexport var option = {\n  URI: URI,\n  map: map_,\n  of: of,\n  ap: ap_,\n  chain: chain_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence,\n  zero: zero,\n  alt: alt_,\n  extend: extend_,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_,\n  throwError: throwError\n}; // -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\n\nexport function elem(E) {\n  return function (a, ma) {\n    return isNone(ma) ? false : E.equals(a, ma.value);\n  };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\n\nexport function exists(predicate) {\n  return function (ma) {\n    return isNone(ma) ? false : predicate(ma.value);\n  };\n}\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\n\nexport function getRefinement(getOption) {\n  return function (a) {\n    return isSome(getOption(a));\n  };\n} // -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.9.0\n */\n\nexport var Do = /*#__PURE__*/of({});\n/**\n * @since 2.8.0\n */\n\nexport var bindTo = function (name) {\n  return map(bindTo_(name));\n};\n/**\n * @since 2.8.0\n */\n\nexport var bind = function (name, f) {\n  return chain(function (a) {\n    return pipe(f(a), map(function (b) {\n      return bind_(a, name, b);\n    }));\n  });\n}; // -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.8.0\n */\n\nexport var apS = function (name, fb) {\n  return flow(map(function (a) {\n    return function (b) {\n      return bind_(a, name, b);\n    };\n  }), ap(fb));\n}; // -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n\n/**\n *\n * @since 2.9.0\n */\n\nexport var traverseArrayWithIndex = function (f) {\n  return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n\n    for (var i = 0; i < arr.length; i++) {\n      var b = f(i, arr[i]);\n\n      if (isNone(b)) {\n        return none;\n      }\n\n      result.push(b.value);\n    }\n\n    return some(result);\n  };\n};\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\n\nexport var traverseArray = function (f) {\n  return traverseArrayWithIndex(function (_, a) {\n    return f(a);\n  });\n};\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\n\nexport var sequenceArray = /*#__PURE__*/traverseArray(identity);","map":{"version":3,"names":["identity","pipe","bind_","bindTo_","flow","isSome","fa","_tag","isNone","none","some","a","value","fromNullable","fromPredicate","predicate","tryCatch","f","e","getLeft","ma","left","getRight","right","fromEither","fold","onNone","onSome","toNullable","toUndefined","undefined","getOrElseW","getOrElse","fromNullableK","_i","arguments","length","apply","mapNullable","chainNullableK","map_","map","ap_","fab","ap","chain_","chain","reduce_","b","reduce","foldMap_","M","foldMapM","foldMap","reduceRight_","reduceRight","traverse_","F","traverseF","traverse","ta","alt_","that","alt","filter_","filter","filterMap_","filterMap","extend_","wa","extend","partition_","partition","partitionMap_","partitionMap","wither_","witherF","wither","wilt_","wiltF","wilt","apFirst","fb","apSecond","of","chainFirst","flatten","altW","zero","throwError","duplicate","empty","compact","defaultSeparate","separate","o","sequence","URI","getShow","S","show","getEq","E","equals","x","y","getOrd","O","compare","getApplySemigroup","concat","getApplyMonoid","getFirstMonoid","getLastMonoid","getMonoid","Functor","Applicative","Monad","Foldable","Alt","Alternative","Extend","Compactable","Filterable","Traversable","Witherable","MonadThrow","option","elem","exists","getRefinement","getOption","Do","bindTo","name","bind","apS","traverseArrayWithIndex","arr","result","i","push","traverseArray","_","sequenceArray"],"sources":["/Users/ngocban/Desktop/imx-integration-reactjs/node_modules/fp-ts/es6/Option.js"],"sourcesContent":["import { identity, pipe, bind_, bindTo_, flow } from './function';\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = { _tag: 'None' };\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable(a) {\n    return a == null ? none : some(a);\n}\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch(f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft(ma) {\n    return ma._tag === 'Right' ? none : some(ma.left);\n}\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight(ma) {\n    return ma._tag === 'Left' ? none : some(ma.right);\n}\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold(onNone, onSome) {\n    return function (ma) { return (isNone(ma) ? onNone() : onSome(ma.value)); };\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toNullable(ma) {\n    return isNone(ma) ? null : ma.value;\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toUndefined(ma) {\n    return isNone(ma) ? undefined : ma.value;\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) { return function (ma) { return (isNone(ma) ? onNone() : ma.value); }; };\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function fromNullableK(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromNullable(f.apply(void 0, a));\n    };\n}\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function chainNullableK(f) {\n    return function (ma) { return (isNone(ma) ? none : fromNullable(f(ma.value))); };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (fa, f) { return pipe(fa, map(f)); };\nvar ap_ = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar chain_ = function (ma, f) { return pipe(ma, chain(f)); };\nvar reduce_ = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar foldMap_ = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar reduceRight_ = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar traverse_ = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar alt_ = function (fa, that) { return pipe(fa, alt(that)); };\nvar filter_ = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/* istanbul ignore next */\nvar filterMap_ = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar extend_ = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar partition_ = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/* istanbul ignore next */\nvar partitionMap_ = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar wither_ = function (F) {\n    var witherF = wither(F);\n    return function (fa, f) { return pipe(fa, witherF(f)); };\n};\n/* istanbul ignore next */\nvar wilt_ = function (F) {\n    var wiltF = wilt(F);\n    return function (fa, f) { return pipe(fa, wiltF(f)); };\n};\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apFirst = function (fb) {\n    return flow(map(function (a) { return function () { return a; }; }), ap(fb));\n};\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apSecond = function (fb) {\n    return flow(map(function () { return function (b) { return b; }; }), ap(fb));\n};\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) { return function (ma) {\n    return isNone(ma) ? none : f(ma.value);\n}; };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chainFirst = function (f) {\n    return chain(function (a) {\n        return pipe(f(a), map(function () { return a; }));\n    });\n};\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isNone(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var compact = flatten;\nvar defaultSeparate = { left: none, right: none };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    var o = pipe(ma, map(function (e) { return ({\n        left: getLeft(e),\n        right: getRight(e)\n    }); }));\n    return isNone(o) ? defaultSeparate : o.value;\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filter = function (predicate) { return function (fa) { return (isNone(fa) ? none : predicate(fa.value) ? fa : none); }; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partition = function (predicate) { return function (fa) {\n    return {\n        left: filter_(fa, function (a) { return !predicate(a); }),\n        right: filter_(fa, predicate)\n    };\n}; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) { return function (f) { return function (ta) { return (isNone(ta) ? F.of(none) : F.map(f(ta.value), some)); }; }; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ta) { return (isNone(ta) ? F.of(none) : F.map(ta.value, some)); }; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wither = function (F) { return function (f) { return function (fa) { return (isNone(fa) ? F.of(none) : f(fa.value)); }; }; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wilt = function (F) { return function (f) { return function (fa) {\n    return isNone(fa)\n        ? F.of({\n            left: none,\n            right: none\n        })\n        : F.map(f(fa.value), function (e) { return ({\n            left: getLeft(e),\n            right: getRight(e)\n        }); });\n}; }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (ma) { return (isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\"); }\n    };\n}\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq(E) {\n    return {\n        equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n    };\n}\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd(O) {\n    return {\n        equals: getEq(O).equals,\n        compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n    };\n}\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid(M) {\n    return {\n        concat: getApplySemigroup(M).concat,\n        empty: some(M.empty)\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : x); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(y) ? x : y); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid(S) {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n        empty: none\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: map_,\n    alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    alt: alt_,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: map_,\n    extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: map_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_,\n    throwError: throwError\n};\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var option = {\n    URI: URI,\n    map: map_,\n    of: of,\n    ap: ap_,\n    chain: chain_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    zero: zero,\n    alt: alt_,\n    extend: extend_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_,\n    throwError: throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem(E) {\n    return function (a, ma) { return (isNone(ma) ? false : E.equals(a, ma.value)); };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists(predicate) {\n    return function (ma) { return (isNone(ma) ? false : predicate(ma.value)); };\n}\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof({});\n/**\n * @since 2.8.0\n */\nexport var bindTo = function (name) { return map(bindTo_(name)); };\n/**\n * @since 2.8.0\n */\nexport var bind = function (name, f) {\n    return chain(function (a) {\n        return pipe(f(a), map(function (b) { return bind_(a, name, b); }));\n    });\n};\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = function (name, fb) {\n    return flow(map(function (a) { return function (b) { return bind_(a, name, b); }; }), ap(fb));\n};\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n *\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = function (f) { return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = f(i, arr[i]);\n        if (isNone(b)) {\n            return none;\n        }\n        result.push(b.value);\n    }\n    return some(result);\n}; };\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/\ntraverseArray(identity);\n"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,OAAhC,EAAyCC,IAAzC,QAAqD,YAArD,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,MAAM,GAAG,UAAUC,EAAV,EAAc;EAAE,OAAOA,EAAE,CAACC,IAAH,KAAY,MAAnB;AAA4B,CAAzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,MAAM,GAAG,UAAUF,EAAV,EAAc;EAAE,OAAOA,EAAE,CAACC,IAAH,KAAY,MAAnB;AAA4B,CAAzD,C,CACP;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,IAAI,GAAG;EAAEF,IAAI,EAAE;AAAR,CAAX;AACP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIG,IAAI,GAAG,UAAUC,CAAV,EAAa;EAAE,OAAQ;IAAEJ,IAAI,EAAE,MAAR;IAAgBK,KAAK,EAAED;EAAvB,CAAR;AAAsC,CAAhE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,YAAT,CAAsBF,CAAtB,EAAyB;EAC5B,OAAOA,CAAC,IAAI,IAAL,GAAYF,IAAZ,GAAmBC,IAAI,CAACC,CAAD,CAA9B;AACH;AACD,OAAO,SAASG,aAAT,CAAuBC,SAAvB,EAAkC;EACrC,OAAO,UAAUJ,CAAV,EAAa;IAAE,OAAQI,SAAS,CAACJ,CAAD,CAAT,GAAeD,IAAI,CAACC,CAAD,CAAnB,GAAyBF,IAAjC;EAAyC,CAA/D;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,QAAT,CAAkBC,CAAlB,EAAqB;EACxB,IAAI;IACA,OAAOP,IAAI,CAACO,CAAC,EAAF,CAAX;EACH,CAFD,CAGA,OAAOC,CAAP,EAAU;IACN,OAAOT,IAAP;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASU,OAAT,CAAiBC,EAAjB,EAAqB;EACxB,OAAOA,EAAE,CAACb,IAAH,KAAY,OAAZ,GAAsBE,IAAtB,GAA6BC,IAAI,CAACU,EAAE,CAACC,IAAJ,CAAxC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBF,EAAlB,EAAsB;EACzB,OAAOA,EAAE,CAACb,IAAH,KAAY,MAAZ,GAAqBE,IAArB,GAA4BC,IAAI,CAACU,EAAE,CAACG,KAAJ,CAAvC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,UAAU,GAAGF,QAAjB,C,CACP;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,IAAT,CAAcC,MAAd,EAAsBC,MAAtB,EAA8B;EACjC,OAAO,UAAUP,EAAV,EAAc;IAAE,OAAQZ,MAAM,CAACY,EAAD,CAAN,GAAaM,MAAM,EAAnB,GAAwBC,MAAM,CAACP,EAAE,CAACR,KAAJ,CAAtC;EAAoD,CAA3E;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgB,UAAT,CAAoBR,EAApB,EAAwB;EAC3B,OAAOZ,MAAM,CAACY,EAAD,CAAN,GAAa,IAAb,GAAoBA,EAAE,CAACR,KAA9B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASiB,WAAT,CAAqBT,EAArB,EAAyB;EAC5B,OAAOZ,MAAM,CAACY,EAAD,CAAN,GAAaU,SAAb,GAAyBV,EAAE,CAACR,KAAnC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAImB,UAAU,GAAG,UAAUL,MAAV,EAAkB;EAAE,OAAO,UAAUN,EAAV,EAAc;IAAE,OAAQZ,MAAM,CAACY,EAAD,CAAN,GAAaM,MAAM,EAAnB,GAAwBN,EAAE,CAACR,KAAnC;EAA4C,CAAnE;AAAsE,CAA3G;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIoB,SAAS,GAAGD,UAAhB,C,CACP;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,aAAT,CAAuBhB,CAAvB,EAA0B;EAC7B,OAAO,YAAY;IACf,IAAIN,CAAC,GAAG,EAAR;;IACA,KAAK,IAAIuB,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;MAC1CvB,CAAC,CAACuB,EAAD,CAAD,GAAQC,SAAS,CAACD,EAAD,CAAjB;IACH;;IACD,OAAOrB,YAAY,CAACI,CAAC,CAACoB,KAAF,CAAQ,KAAK,CAAb,EAAgB1B,CAAhB,CAAD,CAAnB;EACH,CAND;AAOH;AACD;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI2B,WAAW,GAAGC,cAAlB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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"},"metadata":{},"sourceType":"module"}