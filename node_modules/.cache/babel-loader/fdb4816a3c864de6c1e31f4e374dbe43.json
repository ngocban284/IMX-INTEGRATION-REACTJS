{"ast":null,"code":"import { identity } from './function';\nimport * as S from './Semigroup';\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAll.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAll.concat(true, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidAll = {\n  concat: S.semigroupAll.concat,\n  empty: true\n};\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAny.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAny.concat(true, false), true)\n * assert.deepStrictEqual(M.monoidAny.concat(false, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidAny = {\n  concat: S.semigroupAny.concat,\n  empty: false\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidSum = {\n  concat: S.semigroupSum.concat,\n  empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidProduct = {\n  concat: S.semigroupProduct.concat,\n  empty: 1\n};\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidString.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidString = {\n  concat: S.semigroupString.concat,\n  empty: ''\n};\n/**\n * @category instances\n * @since 2.0.0\n */\n\nexport var monoidVoid = {\n  concat: S.semigroupVoid.concat,\n  empty: undefined\n};\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.fold(M.monoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(M.fold(M.monoidSum)([]), 0)\n *\n * @since 2.0.0\n */\n\nexport function fold(M) {\n  return S.fold(M)(M.empty);\n}\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getTupleMonoid() {\n  var monoids = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    monoids[_i] = arguments[_i];\n  }\n\n  return {\n    concat: S.getTupleSemigroup.apply(S, monoids).concat,\n    empty: monoids.map(function (m) {\n      return m.empty;\n    })\n  };\n}\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */\n\nexport function getDualMonoid(M) {\n  return {\n    concat: S.getDualSemigroup(M).concat,\n    empty: M.empty\n  };\n}\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/function'\n * import * as M from 'fp-ts/Monoid'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = M.getFunctionMonoid(M.monoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = M.getFunctionMonoid(M.monoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getFunctionMonoid(M) {\n  return function () {\n    return {\n      concat: S.getFunctionSemigroup(M)().concat,\n      empty: function () {\n        return M.empty;\n      }\n    };\n  };\n} // TODO: swap execution order in v3\n\n/**\n * Endomorphism form a monoid where the `empty` value is the identity function.\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getEndomorphismMonoid() {\n  return {\n    concat: function (x, y) {\n      return function (a) {\n        return x(y(a));\n      };\n    },\n    empty: identity\n  };\n}\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const monoidPoint = M.getStructMonoid<Point>({\n *   x: M.monoidSum,\n *   y: M.monoidSum\n * })\n *\n * assert.deepStrictEqual(monoidPoint.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getStructMonoid(monoids) {\n  var empty = {};\n\n  for (var _i = 0, _a = Object.keys(monoids); _i < _a.length; _i++) {\n    var key = _a[_i];\n    empty[key] = monoids[key].empty;\n  }\n\n  return {\n    concat: S.getStructSemigroup(monoids).concat,\n    empty: empty\n  };\n}\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getMeetMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getMeetMonoid(B) {\n  return {\n    concat: S.getMeetSemigroup(B).concat,\n    empty: B.top\n  };\n}\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getJoinMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category instances\n * @since 2.0.0\n */\n\nexport function getJoinMonoid(B) {\n  return {\n    concat: S.getJoinSemigroup(B).concat,\n    empty: B.bottom\n  };\n}","map":{"version":3,"names":["identity","S","monoidAll","concat","semigroupAll","empty","monoidAny","semigroupAny","monoidSum","semigroupSum","monoidProduct","semigroupProduct","monoidString","semigroupString","monoidVoid","semigroupVoid","undefined","fold","M","getTupleMonoid","monoids","_i","arguments","length","getTupleSemigroup","apply","map","m","getDualMonoid","getDualSemigroup","getFunctionMonoid","getFunctionSemigroup","getEndomorphismMonoid","x","y","a","getStructMonoid","_a","Object","keys","key","getStructSemigroup","getMeetMonoid","B","getMeetSemigroup","top","getJoinMonoid","getJoinSemigroup","bottom"],"sources":["/Users/ngocban/Desktop/imx-integration-reactjs/node_modules/fp-ts/es6/Monoid.js"],"sourcesContent":["import { identity } from './function';\nimport * as S from './Semigroup';\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAll.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAll.concat(true, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAll = {\n    concat: S.semigroupAll.concat,\n    empty: true\n};\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAny.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAny.concat(true, false), true)\n * assert.deepStrictEqual(M.monoidAny.concat(false, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAny = {\n    concat: S.semigroupAny.concat,\n    empty: false\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidSum = {\n    concat: S.semigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidProduct = {\n    concat: S.semigroupProduct.concat,\n    empty: 1\n};\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidString.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidString = {\n    concat: S.semigroupString.concat,\n    empty: ''\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var monoidVoid = {\n    concat: S.semigroupVoid.concat,\n    empty: undefined\n};\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.fold(M.monoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(M.fold(M.monoidSum)([]), 0)\n *\n * @since 2.0.0\n */\nexport function fold(M) {\n    return S.fold(M)(M.empty);\n}\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleMonoid() {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return {\n        concat: S.getTupleSemigroup.apply(S, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    };\n}\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualMonoid(M) {\n    return {\n        concat: S.getDualSemigroup(M).concat,\n        empty: M.empty\n    };\n}\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/function'\n * import * as M from 'fp-ts/Monoid'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = M.getFunctionMonoid(M.monoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = M.getFunctionMonoid(M.monoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionMonoid(M) {\n    return function () { return ({\n        concat: S.getFunctionSemigroup(M)().concat,\n        empty: function () { return M.empty; }\n    }); };\n}\n// TODO: swap execution order in v3\n/**\n * Endomorphism form a monoid where the `empty` value is the identity function.\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEndomorphismMonoid() {\n    return {\n        concat: function (x, y) { return function (a) { return x(y(a)); }; },\n        empty: identity\n    };\n}\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const monoidPoint = M.getStructMonoid<Point>({\n *   x: M.monoidSum,\n *   y: M.monoidSum\n * })\n *\n * assert.deepStrictEqual(monoidPoint.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getStructMonoid(monoids) {\n    var empty = {};\n    for (var _i = 0, _a = Object.keys(monoids); _i < _a.length; _i++) {\n        var key = _a[_i];\n        empty[key] = monoids[key].empty;\n    }\n    return {\n        concat: S.getStructSemigroup(monoids).concat,\n        empty: empty\n    };\n}\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getMeetMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMeetMonoid(B) {\n    return {\n        concat: S.getMeetSemigroup(B).concat,\n        empty: B.top\n    };\n}\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getJoinMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getJoinMonoid(B) {\n    return {\n        concat: S.getJoinSemigroup(B).concat,\n        empty: B.bottom\n    };\n}\n"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA,OAAO,KAAKC,CAAZ,MAAmB,aAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,SAAS,GAAG;EACnBC,MAAM,EAAEF,CAAC,CAACG,YAAF,CAAeD,MADJ;EAEnBE,KAAK,EAAE;AAFY,CAAhB;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,SAAS,GAAG;EACnBH,MAAM,EAAEF,CAAC,CAACM,YAAF,CAAeJ,MADJ;EAEnBE,KAAK,EAAE;AAFY,CAAhB;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIG,SAAS,GAAG;EACnBL,MAAM,EAAEF,CAAC,CAACQ,YAAF,CAAeN,MADJ;EAEnBE,KAAK,EAAE;AAFY,CAAhB;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIK,aAAa,GAAG;EACvBP,MAAM,EAAEF,CAAC,CAACU,gBAAF,CAAmBR,MADJ;EAEvBE,KAAK,EAAE;AAFgB,CAApB;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIO,YAAY,GAAG;EACtBT,MAAM,EAAEF,CAAC,CAACY,eAAF,CAAkBV,MADJ;EAEtBE,KAAK,EAAE;AAFe,CAAnB;AAIP;AACA;AACA;AACA;;AACA,OAAO,IAAIS,UAAU,GAAG;EACpBX,MAAM,EAAEF,CAAC,CAACc,aAAF,CAAgBZ,MADJ;EAEpBE,KAAK,EAAEW;AAFa,CAAjB;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,IAAT,CAAcC,CAAd,EAAiB;EACpB,OAAOjB,CAAC,CAACgB,IAAF,CAAOC,CAAP,EAAUA,CAAC,CAACb,KAAZ,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASc,cAAT,GAA0B;EAC7B,IAAIC,OAAO,GAAG,EAAd;;EACA,KAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;IAC1CD,OAAO,CAACC,EAAD,CAAP,GAAcC,SAAS,CAACD,EAAD,CAAvB;EACH;;EACD,OAAO;IACHlB,MAAM,EAAEF,CAAC,CAACuB,iBAAF,CAAoBC,KAApB,CAA0BxB,CAA1B,EAA6BmB,OAA7B,EAAsCjB,MAD3C;IAEHE,KAAK,EAAEe,OAAO,CAACM,GAAR,CAAY,UAAUC,CAAV,EAAa;MAAE,OAAOA,CAAC,CAACtB,KAAT;IAAiB,CAA5C;EAFJ,CAAP;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASuB,aAAT,CAAuBV,CAAvB,EAA0B;EAC7B,OAAO;IACHf,MAAM,EAAEF,CAAC,CAAC4B,gBAAF,CAAmBX,CAAnB,EAAsBf,MAD3B;IAEHE,KAAK,EAAEa,CAAC,CAACb;EAFN,CAAP;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASyB,iBAAT,CAA2BZ,CAA3B,EAA8B;EACjC,OAAO,YAAY;IAAE,OAAQ;MACzBf,MAAM,EAAEF,CAAC,CAAC8B,oBAAF,CAAuBb,CAAvB,IAA4Bf,MADX;MAEzBE,KAAK,EAAE,YAAY;QAAE,OAAOa,CAAC,CAACb,KAAT;MAAiB;IAFb,CAAR;EAGhB,CAHL;AAIH,C,CACD;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS2B,qBAAT,GAAiC;EACpC,OAAO;IACH7B,MAAM,EAAE,UAAU8B,CAAV,EAAaC,CAAb,EAAgB;MAAE,OAAO,UAAUC,CAAV,EAAa;QAAE,OAAOF,CAAC,CAACC,CAAC,CAACC,CAAD,CAAF,CAAR;MAAiB,CAAvC;IAA0C,CADjE;IAEH9B,KAAK,EAAEL;EAFJ,CAAP;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASoC,eAAT,CAAyBhB,OAAzB,EAAkC;EACrC,IAAIf,KAAK,GAAG,EAAZ;;EACA,KAAK,IAAIgB,EAAE,GAAG,CAAT,EAAYgB,EAAE,GAAGC,MAAM,CAACC,IAAP,CAAYnB,OAAZ,CAAtB,EAA4CC,EAAE,GAAGgB,EAAE,CAACd,MAApD,EAA4DF,EAAE,EAA9D,EAAkE;IAC9D,IAAImB,GAAG,GAAGH,EAAE,CAAChB,EAAD,CAAZ;IACAhB,KAAK,CAACmC,GAAD,CAAL,GAAapB,OAAO,CAACoB,GAAD,CAAP,CAAanC,KAA1B;EACH;;EACD,OAAO;IACHF,MAAM,EAAEF,CAAC,CAACwC,kBAAF,CAAqBrB,OAArB,EAA8BjB,MADnC;IAEHE,KAAK,EAAEA;EAFJ,CAAP;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqC,aAAT,CAAuBC,CAAvB,EAA0B;EAC7B,OAAO;IACHxC,MAAM,EAAEF,CAAC,CAAC2C,gBAAF,CAAmBD,CAAnB,EAAsBxC,MAD3B;IAEHE,KAAK,EAAEsC,CAAC,CAACE;EAFN,CAAP;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAuBH,CAAvB,EAA0B;EAC7B,OAAO;IACHxC,MAAM,EAAEF,CAAC,CAAC8C,gBAAF,CAAmBJ,CAAnB,EAAsBxC,MAD3B;IAEHE,KAAK,EAAEsC,CAAC,CAACK;EAFN,CAAP;AAIH"},"metadata":{},"sourceType":"module"}