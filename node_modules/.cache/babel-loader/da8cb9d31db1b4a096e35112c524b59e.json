{"ast":null,"code":"/**\n * @since 0.5.0\n */\nimport * as t from 'io-ts';\nvar leftLiteral = t.literal('Left');\nvar rightLiteral = t.literal('Right');\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/es6/either'\n * import { left, right } from 'fp-ts/es6/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/es6/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\n\nexport function either(leftCodec, rightCodec, name) {\n  if (name === void 0) {\n    name = \"Either<\" + leftCodec.name + \", \" + rightCodec.name + \">\";\n  }\n\n  return t.union([t.strict({\n    _tag: leftLiteral,\n    left: leftCodec\n  }, \"Left<\" + leftCodec.name + \">\"), t.strict({\n    _tag: rightLiteral,\n    right: rightCodec\n  }, \"Right<\" + leftCodec.name + \">\")], name);\n}","map":{"version":3,"names":["t","leftLiteral","literal","rightLiteral","either","leftCodec","rightCodec","name","union","strict","_tag","left","right"],"sources":["/Users/ngocban/Desktop/imx-integration-reactjs/node_modules/io-ts-types/es6/either.js"],"sourcesContent":["/**\n * @since 0.5.0\n */\nimport * as t from 'io-ts';\nvar leftLiteral = t.literal('Left');\nvar rightLiteral = t.literal('Right');\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/es6/either'\n * import { left, right } from 'fp-ts/es6/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/es6/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either(leftCodec, rightCodec, name) {\n    if (name === void 0) { name = \"Either<\" + leftCodec.name + \", \" + rightCodec.name + \">\"; }\n    return t.union([\n        t.strict({\n            _tag: leftLiteral,\n            left: leftCodec\n        }, \"Left<\" + leftCodec.name + \">\"),\n        t.strict({\n            _tag: rightLiteral,\n            right: rightCodec\n        }, \"Right<\" + leftCodec.name + \">\")\n    ], name);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,KAAKA,CAAZ,MAAmB,OAAnB;AACA,IAAIC,WAAW,GAAGD,CAAC,CAACE,OAAF,CAAU,MAAV,CAAlB;AACA,IAAIC,YAAY,GAAGH,CAAC,CAACE,OAAF,CAAU,OAAV,CAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,MAAT,CAAgBC,SAAhB,EAA2BC,UAA3B,EAAuCC,IAAvC,EAA6C;EAChD,IAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;IAAEA,IAAI,GAAG,YAAYF,SAAS,CAACE,IAAtB,GAA6B,IAA7B,GAAoCD,UAAU,CAACC,IAA/C,GAAsD,GAA7D;EAAmE;;EAC1F,OAAOP,CAAC,CAACQ,KAAF,CAAQ,CACXR,CAAC,CAACS,MAAF,CAAS;IACLC,IAAI,EAAET,WADD;IAELU,IAAI,EAAEN;EAFD,CAAT,EAGG,UAAUA,SAAS,CAACE,IAApB,GAA2B,GAH9B,CADW,EAKXP,CAAC,CAACS,MAAF,CAAS;IACLC,IAAI,EAAEP,YADD;IAELS,KAAK,EAAEN;EAFF,CAAT,EAGG,WAAWD,SAAS,CAACE,IAArB,GAA4B,GAH/B,CALW,CAAR,EASJA,IATI,CAAP;AAUH"},"metadata":{},"sourceType":"module"}